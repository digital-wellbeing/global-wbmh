# Model fitting

```{r packages}
#| results: 'hide'
# Packages
library(ggtext)
library(brms)
library(cmdstanr)
library(ellipse)
library(broom.mixed)
library(scales)
library(ggh4x)
library(tidybayes)
library(ggdist)
library(posterior)
library(parameters)
library(lme4)
library(emmeans)
library(patchwork)
library(bayestestR)
library(lubridate)
library(broom)
library(kableExtra)
library(ggstance)
library(tidyverse)

# MCMC settings
ncores <- min(parallel::detectCores(), 12)
nchains <- 4
options(brms.backend = "cmdstanr")
hmc <- list(
  chains = nchains,
  cores = nchains,
  threads = ncores %/% nchains,
  iter = 1000, 
  warmup = 500,
  refresh = 50,
  adapt_delta = .90, 
  max_treedepth = 10
)
```

```{r}
itu <- read_rds("data/itu.rds")
gwp <- read_rds("data/gwp.rds")
gbd <- read_rds("data/gbd.rds") 
```

## Prepare data for models

Preparing the variables:

- Drop countries with no values
- Transform edge values of internet variable to fit beta
- center year on 2010 (roughly in the middle)
- Intercept and simple effects at 2010
- 1 unit: year
- create 1-year lagged internet adoption variables
- Intercepts are country/grand means
- 1 unit: 100%
- Contrast code factors

```{r}
countries_no_internet <- itu %>% 
  group_by(country) %>% 
  summarise(s = sum(internet, na.rm = TRUE)) %>% 
  filter(s == 0)

itu <- itu %>% 
  filter(!(country %in% countries_no_internet$country))

filter(itu, internet %in% c(0, 1))

itu <- itu %>% 
  mutate(internet = if_else(internet == 0, .0000001, internet)) %>% 
  mutate(internet = if_else(internet == 1, .9999999, internet))

# Create lagged predictors
itu <- itu %>% 
  arrange(region, country, year) %>% 
  group_by(region, country) %>% 
  mutate(
    across(
      c(internet, fixed, mobile), 
      list(`1` = ~lag(., 1)), 
      .names = "{str_sub(.col, 1, 1)}{.fn}"
    )
  )

# Centering predictors within and between countries
itu <- itu %>%
  group_by(country) %>% 
  mutate(
    i1_cb = mean(i1, na.rm = TRUE), # Country average
    i1_cw = i1 - i1_cb, # Year-specific deviation from country average
    f1_cb = mean(f1, na.rm = TRUE),
    f1_cw = f1 - f1_cb,
    m1_cb = mean(m1, na.rm = TRUE),
    m1_cw = m1 - m1_cb,
  ) %>% 
  ungroup() %>% 
  # Grand-mean center the country averages
  mutate(
    across(c(i1_cb, f1_cb, m1_cb), ~. - mean(., na.rm = T))
  )
```

```{r data-prepare}
# Stack outcome data
dat <- bind_rows(gwp, gbd)

# Merge predictors to outcomes
dat <- left_join(dat, itu)

# Arrange data
dat <- arrange(dat, region, country, year)

# Center and scale year, and contrast code sex
dat <- dat %>% 
  mutate(year = (year - 2010) / 10)
```

Identify values to use in mv models

```{r}
# Indicate unique ITU values for MV model
dat <- dat %>% 
  # Unique values exist for each country-year, but must be given for each
  # outcome
  group_by(region, country, year, cause) %>% 
  mutate(itu = 1:n() == 1) %>% 
  ungroup()
```

All the outcome variables are proportions (0-1) at this point. We rescale them to percentages (0-100).

```{r}
# Important: do this for both val AND se
dat <- dat %>% 
  mutate(across(val:se, ~.x*100))
```

Ensure that factors are contrast coded

```{r}
dat <- dat %>% 
  mutate(across(c(sex, age), factor))
options(contrasts = c(unordered = "contr.sum", ordered = "contr.poly"))
options()$contrasts
```


## Model equations

The first model addresses our first research question: To what extent did the outcomes change over time. It will also answer whether changes were different across the demographic groups.

It will also begin to address the issue of associations between internet adoption and well-being, by including a correlation between the country-specific trends in internet adoption and outcomes.

We fit three incrementally more complex versions of this model. First, without demographic covariates, second with, and third with the two-way interactions with time.

We fit the model separately for each outcome.

Model 1a is a multivariate multilevel model of internet adoption and outcome (e.g. Anxiety) over time. The intercepts and coefficients of time are allowed to vary across regions and countries, with a shared correlation matrix of the random effects across the two outcomes.

Internet adoption is treated as Beta-distributed. Outcome rates are treated as gaussian.

Prepare data for this model

$$
\begin{align*}
y_{i[c][r]} &\sim \text{Normal}(\mu^y_{i[c][r]}, \sigma^{2y}) \\

\mu^y_{i[c][r]} &= \beta^{y}_{0} + \gamma^{y}_{0[c]} + \delta^{y}_{0[r]} +
\beta^y_{1}\text{t}_i + \gamma^{y}_{1[c]}\text{t}_i + \delta^{y}_{1[r]}\text{t}_i  \\

x_{i[c][r]} &\sim 
\text{Beta}(\mu^x_{i[c][r]}, \phi^x) \\

\mu^x_{i[c][r]} &= \text{logit}(
\beta^{x}_{0} + \gamma^{x}_{0[c]} + \delta^{x}_{0[r]} +
\beta^x_{1}\text{t}_i + \gamma^{x}_{1[c]}\text{t}_i + \delta^{x}_{1[r]}\text{t}_i) \\

\left[\begin{array}{c}
\gamma^y_{0[c]} \\ \gamma^y_{1[c]} \\ \gamma^x_{0[c]} \\ \gamma^x_{1[c]}
\end{array}\right] 
&\sim MVN(
\left[\begin{array}{c}
0 \\ 0 \\ 0 \\ 0
\end{array}\right],
\Sigma^c
),

\left[\begin{array}{c}
\delta^y_{0[r]} \\ \delta^y_{1[r]} \\ \delta^x_{0[r]} \\ \delta^x_{1[r]}
\end{array}\right] 
\sim MVN(
\left[\begin{array}{c}
0 \\ 0 \\ 0 \\ 0
\end{array}\right],
\Sigma^r
)
\end{align*}
\mathbf{\beta}
$$

We then define the model formulas in brms' formula syntax. First, for internet adoption, we take care to indicate that each internet adoption datum should be modelled only once, because the values are repeated in the outcome data table. To do this we use `resp_subset(itu)`, which includes only unique rows of ITU data in the model. The `|c|` and `|r|` separating the random effects from their grouping factors indicate a shared correlation matrix, also indicated in the next model formula.

```{r}
# Define a model of internet proportion over year
bf_itu <- bf(
  internet | resp_subset(itu) ~ 
    year + 
    (year |c| country) +
    (year |r| region), 
  family = Beta()
)
```

Here, we specify the outcome model. Note the `|c|` and `|r|` that link the countries' and regions', respectively, random effects of this model with the previous' model. Then, we specify `resp_se(se, sigma = TRUE)` to enable "meta-regression" with known standard errors. In addition, it leads to the residual variance to be estimated.

```{r}
# Define models of outcomes
bf_1 <- bf(
  val ~ 
    year * sex + year * age + 
    (year * sex + year * age |c| country) +
    (year * sex + year * age |r| region),
  family = gaussian(),
  unused = ~ cause
)

bf_1_se <- bf(
  bf(val | resp_se(se, sigma = TRUE) ~ 
       year * sex + year * age +
       (year * sex + year * age |c| country) +
       (year * sex + year * age |r| region),
     sigma ~ 1
  ),
  family = gaussian(),
  unused = ~ cause
)

bf_2 <- bf(
  val ~ 
    year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb + 
    (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
    (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
  family = gaussian(),
  unused = ~ cause
)

bf_2_se <- bf(
  bf(val | resp_se(se, sigma = TRUE) ~ 
       year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb + 
       (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
       (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
     sigma ~ 1
  ),
  family = gaussian(),
  unused = ~ cause
)

bf_2_f <- bf(
  val ~ 
    year * sex + year * age + f1_cw * sex + f1_cw * age + f1_cb + 
    (year * sex + year * age + f1_cw * sex + f1_cw * age | country) +
    (year * sex + year * age + f1_cw * sex + f1_cw * age | region),
  family = gaussian(), 
  unused = ~ cause
)

bf_2_m <- bf(
  val ~ 
    year * sex + year * age + m1_cw * sex + m1_cw * age + m1_cb + 
    (year * sex + year * age + m1_cw * sex + m1_cw * age | country) +
    (year * sex + year * age + m1_cw * sex + m1_cw * age | region),
  family = gaussian(),
  unused = ~ cause
)
```

## Fit all models

```{r}
models <- tibble(
  model = c("1", "1-se", "2", "2-se", "2-f", "2-m"),
  formula = list(
    bf_itu + bf_1 + set_rescor(FALSE),
    bf_itu + bf_1_se + set_rescor(FALSE),
    bf_2,
    bf_2_se,
    bf_2_f,
    bf_2_m
  )
)
fits <- dat %>% 
  # Could nest but need this to include group key in nested tibble
  group_by(cause) %>% 
  summarise(data = list(cur_data_all())) %>% 
  crossing(models)

# Don't estimate se models for selfharm--doesn't converge
fits <- fits %>% 
  filter(!(cause=="Selfharm" & str_detect(model, "se")))

# Estimate all models
fits <- fits %>% 
  mutate(
    fit = pmap(
      list(cause=cause, data=data, model=model, formula=formula),
      function(cause, data, model, formula)
        brm(
          formula = formula,
          data = data,
          chains = hmc$chains,
          cores = hmc$cores,
          threads = hmc$threads,
          iter = hmc$iter,
          warmup = hmc$warmup,
          refresh = hmc$refresh,
          control = list(
            adapt_delta = hmc$adapt_delta,
            max_treedepth = hmc$max_treedepth
          ),
          file = str_glue("output/brm-{model}-{cause}")
        )
    )
  )
```

### Checking

Diagnostics: convergence and effective samples size

```{r}
diag_1 <- fits %>% 
  filter(model == "1") %>% 
  mutate(
    out = 
      map(
        fit, 
        ~as_draws_df(., variable = "^b_|^sd_|^cor_", regex = TRUE) %>% 
          summarise_draws(samples = length, default_convergence_measures())
      )
  ) %>% 
  select(-fit) %>% 
  unnest(out)
diag_1 %>%  
  kbl(
    caption = "HMC Diagnostics, Model 1",
    digits = c(0,0,0,2,0,0)
  ) %>% 
  kable_paper(html_font = Font) %>% 
  column_spec(
    4, 
    color = "white",
    background = spec_color(
      diag_1$rhat, 
      direction = 1, 
      option = "C", 
      end = .7
    )
  )
```

```{r}
ppcheck_1 <- fits %>% 
  filter(model == "1")
  mutate(
    out = map(
      fit, 
      ~pp_check(
        .x, 
        ndraws = 10, 
        type = "dens_overlay_grouped",
        group = "region",
        resp = "val", 
        newdata = .x$data
      ) + 
        facet_wrap("group", nrow = 1, scales = "free")
    )
  )
wrap_plots(ppcheck_1$out, nrow = 6) &
  scale_x_continuous(
    breaks = pretty_breaks(2),
    labels = function(x) percent(x/100)
  ) &
  theme(legend.position = "none")
```
