# Model fitting

```{r packages}
#| results: 'hide'
# Packages
library(ggtext)
library(brms)
library(cmdstanr)
library(ellipse)
library(broom.mixed)
library(scales)
library(ggh4x)
library(tidybayes)
library(ggdist)
library(posterior)
library(parameters)
library(lme4)
library(emmeans)
library(patchwork)
library(bayestestR)
library(lubridate)
library(broom)
library(kableExtra)
library(ggstance)
library(tidyverse)

# MCMC settings
options(brms.backend = "cmdstanr")
hmc <- list(
  chains = 4,
  cores = 4,
  threads = 3,
  iter = 1500, 
  warmup = 750,
  refresh = 10,
  adapt_delta = .90, 
  max_treedepth = 10
)
```

```{r}
itu <- read_rds("data/itu.rds")
gbd <- read_rds("data/gbd.rds") # 10 to 24 year olds
```

## Prepare data for models

Preparing the variables:

- Transform edge values of internet variable to fit beta
- center year on 2010 (roughly in the middle)
- Intercept and simple effects at 2010
- 1 unit: year
- create 1-year lagged internet adoption variables
- Intercepts are country/grand means
- 1 unit: 100%
- Contrast code factors

```{r data-prepare}
# Predictors

# Transform edge proportions to fit beta distribution
itu <- itu %>% 
  mutate(internet = if_else(internet == 0, .0000001, internet)) %>% 
  mutate(internet = if_else(internet == 1, .9999999, internet))

# Create lagged predictors
itu <- itu %>% 
  arrange(country, year) %>% 
  group_by(country) %>% 
  mutate(
    across(
      c(internet, fixed, mobile), 
      list(`1` = ~lag(., 1)), 
      .names = "{str_sub(.col, 1, 1)}{.fn}"
    )
  )

# Centering within and between countries
itu <- itu %>%
  group_by(country) %>% 
  mutate(
    i1_cb = mean(i1, na.rm = TRUE), # Country average
    i1_cw = i1 - i1_cb # Year-specific deviation from country average
  ) %>% 
  ungroup() %>% 
  # Grand-mean center the country averages
  mutate(i1_cb = i1_cb - mean(i1, na.rm = TRUE))

# Outcomes

# Merge predictors to outcomes
dat <- left_join(gbd, itu)

# Center and scale year, and contrast code factors
dat <- dat %>% 
  mutate(year = (year - 2010) / 10)
dat$sex <- factor(dat$sex)
contrasts(dat$sex) <- "contr.sum"
dat$age <- factor(dat$age)
contrasts(dat$age) <- "contr.sum"

# For brms multivariate data subsetting: variable to indicate unique ITU values
dat <- dat %>% 
  group_by(country, year) %>% 
  mutate(itu = 1:n() == 1) %>% 
  ungroup()
```

All the outcome variables are proportions (0-1) at this point. They need to be rescaled for HMC efficiency (self-harm models do not converge at this scale.) So remember to back-transform when interpreting results!

```{r}
# Save this so its easy to use later to back-transform
dat %>%
  group_by(cause) %>%
  summarise(median = median(val), min = min(val), max = max(val))

# Important: do this for both val AND se
dat <- dat %>% 
  group_by(cause) %>% 
  mutate(across(val:se, ~.x*100)) %>% 
  ungroup()

dat %>%
  group_by(cause) %>%
  summarise(median = median(val), min = min(val), max = max(val))
```

## Model 1

The first model addresses our first research question: To what extent did the outcomes change over time. It will also answer whether changes were different across the demographic groups.

It will also begin to address the issue of associations between internet adoption and well-being, by including a correlation between the country-specific trends in internet adoption and outcomes.

We fit three incrementally more complex versions of this model. First, without demographic covariates, second with, and third with the two-way interactions with time.

We fit the model separately for each outcome.

### Model 1a

Model 1a is a multivariate multilevel model of internet adoption and outcome (e.g. Anxiety) over time. The intercepts and coefficients of time are allowed to vary across regions and countries, with a shared correlation matrix of the random effects across the two outcomes.

Internet adoption is treated as Beta-distributed. Outcome rates, the GBD estimates, are treated as Gaussian with a known standard error, resulting in a "meta-regression" model of the outcomes.

$$
\begin{align*}
y_{i[c][r]} &\sim \text{Normal}(\mu^y_{i[c][r]}, \sigma^{2y}v_i) \\

\mu^y_{i[c][r]} &= \beta^{y}_{0} + \gamma^{y}_{0[c]} + \delta^{y}_{0[r]} +
\beta^y_{1}\text{t}_i + \gamma^{y}_{1[c]}\text{t}_i + \delta^{y}_{1[r]}\text{t}_i  \\

x_{i[c][r]} &\sim 
\text{Beta}(\mu^x_{i[c][r]}, \phi^x) \\

\mu^x_{i[c][r]} &= \text{logit}(
\beta^{x}_{0} + \gamma^{x}_{0[c]} + \delta^{x}_{0[r]} +
\beta^x_{1}\text{t}_i + \gamma^{x}_{1[c]}\text{t}_i + \delta^{x}_{1[r]}\text{t}_i) \\

\left[\begin{array}{c}
\gamma^y_{0[c]} \\ \gamma^y_{1[c]} \\ \gamma^x_{0[c]} \\ \gamma^x_{1[c]}
\end{array}\right] 
&\sim MVN(
\left[\begin{array}{c}
0 \\ 0 \\ 0 \\ 0
\end{array}\right],
\Sigma^c
),

\left[\begin{array}{c}
\delta^y_{0[r]} \\ \delta^y_{1[r]} \\ \delta^x_{0[r]} \\ \delta^x_{1[r]}
\end{array}\right] 
\sim MVN(
\left[\begin{array}{c}
0 \\ 0 \\ 0 \\ 0
\end{array}\right],
\Sigma^r
)
\end{align*}
$$

We then define the model formulas in brms' formula syntax. First, for internet adoption, we take care to indicate that each internet adoption datum should be modelled only once, because the values are repeated in the outcome data table. To do this we use `resp_subset(itu)`, which includes only unique rows of ITU data in the model. The `|c|` and `|r|` separating the random effects from their grouping factors indicate a shared correlation matrix, also indicated in the next model formula.

```{r}
# Define a model of internet proportion over year
bf_itu <- bf(
  internet | resp_subset(itu) ~ 
    year + 
    (year |c| country) +
    (year |r| region), 
  family = Beta()
)
```

Here, we specify the outcome model. Note the `|c|` and `|r|` that link the countries' and regions', respectively, random effects of this model with the previous' model. Then, we specify `resp_se(se, sigma = TRUE)` to enable "meta-regression" with known standard errors. In addition, it leads to the residual variance to be estimated.

```{r}
# Define models of outcomes
bf_1a <- bf(
  val | resp_se(se, sigma = TRUE) ~ 
    year + 
    (year |c| country) +
    (year |r| region),
  family = gaussian()
)
```

We then compile the model once, such that it can be updated with subsets of the data (the different outcomes) without having to compile again. 

```{r}
fit_1a <- brm(
  bf_itu + bf_1a + set_rescor(FALSE),
  data = filter(dat, cause == "Anxiety"),
  chains = 0,
  threads = hmc$threads,
  file = "output/brm-1a"
)
```

Then fit the model. Note we don't need this for now because the relevant estimates are provided by model 1c.

```{r eval = FALSE}
fits_1a <- dat %>% 
  group_by(cause) %>% 
  summarise(
    fit = list(
      update(
        fit_1a, 
        newdata = cur_data_all(),
        chains = hmc$chains, cores = hmc$cores, threads = hmc$threads,
        iter = hmc$iter, warmup = hmc$warmup,
        control = list(adapt_delta = hmc$d, max_treedepth = hmc$m),
        file = str_glue("output/brm-1a-{cur_group()}")
      )
    )
  )
```

### Model 1b

Model 1b is as 1a but we include age (10 to 14, 15 to 19, 20 to 24) and sex as covariates.

```{r}
bf_1b <- bf(
  val | resp_se(se, sigma = TRUE) ~ 
    year + sex + age + 
    (year + sex + age |c| country) +
    (year + sex + age |r| region),
  family = gaussian()
)
```

Then fit the model as above, first compiling and then updating for each outcome. Note not fitted for now--relevant estimates are in model 1c.

```{r eval = FALSE}
fit_1b <- brm(
  bf_itu + bf_1b + set_rescor(FALSE),
  data = filter(dat, cause == "Anxiety"),
  chains = 0,
  threads = hmc$threads,
  file = "output/brm-1b"
)

fits_1b <- dat %>% 
  group_by(cause) %>% 
  summarise(
    fit = list(
      update(
        fit_1b, 
        newdata = cur_data_all(),
        chains = hmc$chains, cores = hmc$cores, threads = hmc$threads,
        iter = hmc$iter, warmup = hmc$warmup,
        control = list(adapt_delta = hmc$d, max_treedepth = hmc$m),
        file = str_glue("output/brm-1b-{cur_group()}")
      )
    )
  )
```

### Model 1c

Model 1c further expands 1b to include the two-way interactive terms between age and year, and sex and year. Thus we get age and sex-specific trajectories over time. We reuse the prior distributions from 1b.

This takes about 3.5 hours per 1000 iterations (per model).

```{r}
bf_1c <- bf(
  val | resp_se(se, sigma = TRUE) ~ 
    year * sex + year * age + 
    (year * sex + year * age |c| country) +
    (year * sex + year * age |r| region),
  family = gaussian()
)

# Compile model separately for each outcome to give independent default priors
fits_1c <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit = list(
      brm(
        formula = bf_itu + bf_1c + set_rescor(FALSE), 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-1c-{cur_group()}")
      )
    )
  )

bf_1c_no_se <- bf(
  val ~ 
    year * sex + year * age + 
    (year * sex + year * age |c| country) +
    (year * sex + year * age |r| region),
  family = gaussian()
)

# Compile model separately for each outcome to give independent default priors
fits_1c <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit_no_se = list(
      brm(
        formula = bf_itu + bf_1c_no_se + set_rescor(FALSE), 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-1c-no-se-{cur_group()}")
      )
    )
  )
```

### Checking

Diagnostics: convergence and effective samples size

```{r}
f1d <- fits_1c %>% 
  mutate(
    out = 
      map(
        fit, 
        ~as_draws_df(., variable = "^b_|^sd_|^cor_", regex = TRUE) %>% 
          summarise_draws(samples = length, default_convergence_measures())
      )
  ) %>% 
  select(-fit) %>% 
  unnest(out)
f1d %>%  
  kbl(
    caption = "HMC Diagnostics, Model 1c",
    digits = c(0,0,0,2,0,0)
  ) %>% 
  kable_paper(html_font = Font) %>% 
  column_spec(
    4, 
    color = "white",
    background = spec_color(
      f1d$rhat, 
      direction = 1, 
      option = "C", 
      end = .7
    )
  )
```

```{r}
tmp <- fits_1c %>% 
  mutate(
    out = map(
      fit, 
      ~pp_check(
        .x, 
        ndraws = 10, 
        type = "dens_overlay_grouped",
        group = "region",
        resp = "val", 
        newdata = .x$data
      ) + facet_wrap("group", nrow = 1, scales = "free")
    )
  )
wrap_plots(tmp$out, nrow = 3) &
  scale_x_continuous(
    breaks = pretty_breaks(2),
    labels = function(x) percent(x/100)
  )
```


### Summary

We then display the model's population-level parameters

```{r}
fits_1 %>% 
  mutate(
    out = map(
      fit, 
      ~as_draws_df(.x, variable = "^b_", regex = TRUE) %>% 
        summarise_draws(
          mean, quantile, rhat, 
          .args = list(probs = c(.025, .975))
        )
    )
  ) %>% 
  select(-fit) %>% 
  unnest(out) %>% 
  mutate(across(where(is.numeric), ~round(., 2))) %>% 
  mutate(
    result = str_glue(
      "{mean} ({`2.5%`}, {`97.5%`}) [rh = {round(rhat, 1)}]"
    )
  ) %>% 
  select(-c(mean, `2.5%`, `97.5%`, rhat)) %>% 
  pivot_wider(names_from = model, values_from = result) %>% 
  kbl() %>% 
  kable_paper(html_font = Font)
```

## Model 2

Model 2 is a modification of Model 1. First, we now switch to looking at internet use more specifically as a predictor, and therefore implement a univariate model of each outcome. Second, we include within- and between-country centred 1-year-lagged internet adoption values as predictors in the model. 

We fit this model in two increasingly complex forms, corresponding to models 1b and 1c, but with the addition of the internet adoption predictors, and one outcome model only.

2c takes about 5 hours per 1000 iterations.

```{r}
bf_2b <- bf(
  val | resp_se(se, sigma = TRUE) ~ 
    year + sex + age + i1_cw + i1_cb +
    (year + sex + age + i1_cw | country) +
    (year + sex + age + i1_cw | region),
  family = gaussian(), 
  unused = ~ cause # Save this variable in the data frame
)
fit_2b <- brm(
  bf_2b,
  data = filter(dat, cause == "Anxiety"),
  chains = 0,
  threads = hmc$threads,
  file = "output/brm-2b"
)
fits_2b <- dat %>% 
  group_by(cause) %>% 
  summarise(
    fit = list(
      update(
        fit_2b, 
        newdata = cur_data_all(),
        chains = hmc$chains, cores = hmc$cores, threads = hmc$threads,
        iter = hmc$iter, warmup = hmc$warmup, refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-2b-{cur_group()}")
      )
    )
  )

bf_2c <- bf(
  val | se(se, sigma = TRUE) ~ 
    year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb + 
    (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
    (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
  family = gaussian()
)

bf_2c_no_se <- bf(
  val ~ 
    year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb + 
    (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
    (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
  family = gaussian()
)

# Compile model separately for each outcome to give independent default priors
fits_2c <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit = list(
      brm(
        formula = bf_2c, 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-2c-{cur_group()}")
      )
    )
  )

fits_2c <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit_no_se = list(
      brm(
        formula = bf_2c_no_se, 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-2c-no-se-{cur_group()}")
      )
    )
  )
```

### Checking

Diagnostics: convergence and effective samples size

```{r}
f2d <- fits_2c %>% 
  mutate(
    out = 
      map(
        fit, 
        ~as_draws_df(., variable = "^b_|^sd_", regex = TRUE) %>% 
          summarise_draws(samples = length, default_convergence_measures())
      )
  ) %>% 
  select(-fit) %>% 
  unnest(out)
f2d %>%  
  kbl(
    caption = "HMC Diagnostics, Model 2c",
    digits = c(0,0,0,2,0,0)
  ) %>% 
  kable_paper(html_font = Font, full_width = FALSE) %>% 
  column_spec(
    4, 
    color = "white",
    background = spec_color(
      f2d$rhat, 
      direction = 1, 
      option = "C", 
      end = .7
    )
  ) %>% 
  scroll_box(height = "600px", width = "800px")
```

```{r}
tmp <- fits_2c %>% 
  mutate(
    out = map(
      fit, 
      ~pp_check(
        .x, 
        ndraws = 10, 
        type = "dens_overlay_grouped",
        group = "region",
        resp = "val", 
        newdata = .x$data
      ) + 
        facet_wrap("group", nrow = 1, scales = "free_y")
    )
  )
wrap_plots(tmp$out, nrow = 3) &
  scale_x_continuous(
    breaks = pretty_breaks(2),
    labels = function(x) percent(x/100, 1)
  )
```

### Summary

We then display the model's population-level parameters

```{r}
tmp <- fits_2c %>% 
  mutate(
    out = map(
      fit, 
      ~as_draws_df(.x, variable = "^b_", regex = TRUE) %>% 
        summarise_draws(
          mean, quantile, rhat, 
          .args = list(probs = c(.025, .975))
        )
    )
  ) %>% 
  select(-fit) %>% 
  unnest(out) %>% 
  mutate(across(where(is.numeric), ~round(., 2))) %>% 
  mutate(
    result = str_glue(
      "b = {mean} ({`2.5%`}, {`97.5%`})"
    )
  ) %>% 
  rowwise() %>% 
  select(-c(mean, `2.5%`, `97.5%`, rhat)) %>% 
  pivot_wider(names_from = cause, values_from = result)
tmp %>%   
  kbl() %>% 
  kable_paper(html_font = Font) 
```

Coefficients

```{r}
tmp <- fits_2c %>% 
  mutate(
    out = map(
      fit, 
      ~emtrends(.x, var = "i1_cw", by = c("sex", "age"))
    )
  ) %>% 
  select(-fit)
tmp %>% 
  mutate(out = map(out, ~as.data.frame(out))) %>% 
  unnest(out) %>% 
  select(cause, sex, age, i1_cw.trend, lower.HPD, upper.HPD) %>% 
  kbl(digits = 3) %>% 
  kable_minimal(full_width = FALSE)
```
