# Model fitting

```{r packages}
#| results: 'hide'
# Packages
library(ggtext)
library(brms)
library(cmdstanr)
library(ellipse)
library(broom.mixed)
library(scales)
library(ggh4x)
library(tidybayes)
library(ggdist)
library(posterior)
library(parameters)
library(lme4)
library(emmeans)
library(patchwork)
library(bayestestR)
library(lubridate)
library(broom)
library(kableExtra)
library(ggstance)
library(tidyverse)

# MCMC settings
options(brms.backend = "cmdstanr")
hmc <- list(
  chains = 4,
  cores = 4,
  threads = 3,
  iter = 2000, 
  warmup = 1000,
  refresh = 50,
  adapt_delta = .90, 
  max_treedepth = 10
)
```

```{r}
itu <- read_rds("data/itu.rds")
gbd <- read_rds("data/gbd.rds") # 10 to 24 year olds
```

## Prepare data for models

Preparing the variables:

- Transform edge values of internet variable to fit beta
- center year on 2010 (roughly in the middle)
- Intercept and simple effects at 2010
- 1 unit: year
- create 1-year lagged internet adoption variables
- Intercepts are country/grand means
- 1 unit: 100%
- Contrast code factors

```{r data-prepare}
# Merge predictors to outcomes
dat <- left_join(gbd, itu)

# Center and scale year, and contrast code factors
dat <- dat %>% 
  mutate(year = (year - 2010) / 10)
dat$sex <- factor(dat$sex)
contrasts(dat$sex) <- "contr.sum"
dat$age <- factor(dat$age)
contrasts(dat$age) <- "contr.sum"
```

All the outcome variables are proportions (0-1) at this point. We rescale them to percentages (0-100).

```{r}
# Important: do this for both val AND se
dat <- dat %>% 
  mutate(across(val:se, ~.x*100))
```

## Model 1

The first model addresses our first research question: To what extent did the outcomes change over time. It will also answer whether changes were different across the demographic groups.

It will also begin to address the issue of associations between internet adoption and well-being, by including a correlation between the country-specific trends in internet adoption and outcomes.

We fit three incrementally more complex versions of this model. First, without demographic covariates, second with, and third with the two-way interactions with time.

We fit the model separately for each outcome.

### Estimate

Model 1a is a multivariate multilevel model of internet adoption and outcome (e.g. Anxiety) over time. The intercepts and coefficients of time are allowed to vary across regions and countries, with a shared correlation matrix of the random effects across the two outcomes.

Internet adoption is treated as Beta-distributed. Outcome rates are treated as gaussian.

Prepare data for this model

```{r}
dat_model1 <- dat %>% 
  # Transform edge proportions to fit beta distribution
  mutate(internet = if_else(internet == 0, .0000001, internet)) %>% 
  mutate(internet = if_else(internet == 1, .9999999, internet)) %>% 
  # Indicate unique ITU values for MV model...
  arrange(region, country, year, cause, sex, age) %>% 
  # ...Use only the first internet value within a year-country
  group_by(region, country, year) %>% 
  mutate(itu = 1:n() == 1) %>% 
  ungroup()
```

$$
\begin{align*}
y_{i[c][r]} &\sim \text{Normal}(\mu^y_{i[c][r]}, \sigma^{2y}) \\

\mu^y_{i[c][r]} &= \beta^{y}_{0} + \gamma^{y}_{0[c]} + \delta^{y}_{0[r]} +
\beta^y_{1}\text{t}_i + \gamma^{y}_{1[c]}\text{t}_i + \delta^{y}_{1[r]}\text{t}_i  \\

x_{i[c][r]} &\sim 
\text{Beta}(\mu^x_{i[c][r]}, \phi^x) \\

\mu^x_{i[c][r]} &= \text{logit}(
\beta^{x}_{0} + \gamma^{x}_{0[c]} + \delta^{x}_{0[r]} +
\beta^x_{1}\text{t}_i + \gamma^{x}_{1[c]}\text{t}_i + \delta^{x}_{1[r]}\text{t}_i) \\

\left[\begin{array}{c}
\gamma^y_{0[c]} \\ \gamma^y_{1[c]} \\ \gamma^x_{0[c]} \\ \gamma^x_{1[c]}
\end{array}\right] 
&\sim MVN(
\left[\begin{array}{c}
0 \\ 0 \\ 0 \\ 0
\end{array}\right],
\Sigma^c
),

\left[\begin{array}{c}
\delta^y_{0[r]} \\ \delta^y_{1[r]} \\ \delta^x_{0[r]} \\ \delta^x_{1[r]}
\end{array}\right] 
\sim MVN(
\left[\begin{array}{c}
0 \\ 0 \\ 0 \\ 0
\end{array}\right],
\Sigma^r
)
\end{align*}
\mathbf{\beta}
$$

We then define the model formulas in brms' formula syntax. First, for internet adoption, we take care to indicate that each internet adoption datum should be modelled only once, because the values are repeated in the outcome data table. To do this we use `resp_subset(itu)`, which includes only unique rows of ITU data in the model. The `|c|` and `|r|` separating the random effects from their grouping factors indicate a shared correlation matrix, also indicated in the next model formula.

```{r}
# Define a model of internet proportion over year
bf_itu <- bf(
  internet | resp_subset(itu) ~ 
    year + 
    (year |c| country) +
    (year |r| region), 
  family = Beta()
)
```

Here, we specify the outcome model. Note the `|c|` and `|r|` that link the countries' and regions', respectively, random effects of this model with the previous' model. Then, we specify `resp_se(se, sigma = TRUE)` to enable "meta-regression" with known standard errors. In addition, it leads to the residual variance to be estimated.

```{r}
# Define models of outcomes
bf_1 <- bf(
  val ~ 
    year * sex + year * age + 
    (year * sex + year * age |c| country) +
    (year * sex + year * age |r| region),
  family = gaussian()
)

bf_1_se <- bf(
  bf(val | resp_se(se, sigma = TRUE) ~ 
       year * sex + year * age +
       (year * sex + year * age |c| country) +
       (year * sex + year * age |r| region),
     sigma ~ 1
  ),
  family = brmsfamily("gaussian", link = "log", link_sigma = "log")
)
```

```{r}
fits_1 <- dat_model1 %>%
  group_by(cause) %>% 
  summarise(
    fit = list(
      brm(
        formula = bf_itu + bf_1 + set_rescor(FALSE), 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-1-{cur_group()}")
      )
    )
  )

# fits_1 <- dat_model1 %>%
#   group_by(cause) %>% 
#   summarise(
#     fit_se = list(
#       brm(
#         formula = bf_itu + bf_1_se + set_rescor(FALSE), 
#         data = cur_data_all(),
#         chains = hmc$chains, 
#         cores = hmc$cores, 
#         threads = hmc$threads,
#         iter = hmc$iter, 
#         warmup = hmc$warmup, 
#         refresh = hmc$refresh,
#         control = list(
#           adapt_delta = hmc$adapt_delta, 
#           max_treedepth = hmc$max_treedepth
#         ),
#         file = str_glue("output/brm-1-se-{cur_group()}")
#       )
#     )
#   )
```

### Checking

Diagnostics: convergence and effective samples size

```{r}
f1d <- fits_1 %>% 
  mutate(
    out = 
      map(
        fit, 
        ~as_draws_df(., variable = "^b_|^sd_|^cor_", regex = TRUE) %>% 
          summarise_draws(samples = length, default_convergence_measures())
      )
  ) %>% 
  select(-fit) %>% 
  unnest(out)
f1d %>%  
  kbl(
    caption = "HMC Diagnostics, Model 1c",
    digits = c(0,0,0,2,0,0)
  ) %>% 
  kable_paper(html_font = Font) %>% 
  column_spec(
    4, 
    color = "white",
    background = spec_color(
      f1d$rhat, 
      direction = 1, 
      option = "C", 
      end = .7
    )
  )
```

```{r}
tmp <- fits_1 %>% 
  mutate(
    out = map(
      fit, 
      ~pp_check(
        .x, 
        ndraws = 10, 
        type = "dens_overlay_grouped",
        group = "region",
        resp = "val", 
        newdata = .x$data
      ) + 
        facet_wrap("group", nrow = 1, scales = "free")
    )
  )
wrap_plots(tmp$out, nrow = 3) &
  scale_x_continuous(
    breaks = pretty_breaks(2),
    labels = function(x) percent(x/100)
  )
```

## Model 2

Prepare data for this model

```{r}
# Create lagged predictors
dat <- dat %>% 
  arrange(region, country, cause, sex, age, year) %>% 
  group_by(region, country, cause, sex, age) %>% 
  mutate(
    across(
      c(internet, fixed, mobile), 
      list(`1` = ~lag(., 1)), 
      .names = "{str_sub(.col, 1, 1)}{.fn}"
    )
  )

# Centering within and between countries
dat <- dat %>%
  group_by(country) %>% 
  mutate(
    i1_cb = mean(i1, na.rm = TRUE), # Country average
    i1_cw = i1 - i1_cb, # Year-specific deviation from country average
    f1_cb = mean(f1, na.rm = TRUE),
    f1_cw = f1 - f1_cb,
    m1_cb = mean(m1, na.rm = TRUE),
    m1_cw = m1 - m1_cb,
  ) %>% 
  ungroup() %>% 
  # Grand-mean center the country averages
  mutate(
    across(c(i1_cb, f1_cb, m1_cb), ~. - mean(., na.rm = T))
  )
```


Model 2 is a modification of Model 1. First, we now switch to looking at internet use more specifically as a predictor, and therefore implement a univariate model of each outcome. Second, we include within- and between-country centred 1-year-lagged internet adoption values as predictors in the model. 

We fit this model in two increasingly complex forms, corresponding to models 1b and 1c, but with the addition of the internet adoption predictors, and one outcome model only.

2c takes about 5 hours per 1000 iterations.

```{r}
bf_2 <- bf(
  val ~ 
    year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb + 
    (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
    (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
  family = gaussian()
)

bf_2_se <- bf(
  bf(val | resp_se(se, sigma = TRUE) ~ 
       year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb + 
       (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
       (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
     sigma ~ 1
  ),
  family = brmsfamily("gaussian", link = "log", link_sigma = "log")
)


# Compile model separately for each outcome to give independent default priors
fits_2 <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit = list(
      brm(
        formula = bf_2, 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-2-{cur_group()}")
      )
    )
  )

# fits_2 <- dat %>%
#   group_by(cause) %>% 
#   summarise(
#     fit_se = list(
#       brm(
#         formula = bf_2_se, 
#         data = cur_data_all(),
#         chains = hmc$chains, 
#         cores = hmc$cores, 
#         threads = hmc$threads,
#         iter = hmc$iter, 
#         warmup = hmc$warmup, 
#         refresh = hmc$refresh,
#         control = list(
#           adapt_delta = hmc$adapt_delta, 
#           max_treedepth = hmc$max_treedepth
#         ),
#         file = str_glue("output/brm-2-se-{cur_group()}")
#       )
#     )
#   )
```

### Checking

Diagnostics: convergence and effective samples size

```{r}
f2d <- fits_2 %>% 
  mutate(
    out = 
      map(
        fit, 
        ~as_draws_df(., variable = "^b_|^sd_", regex = TRUE) %>% 
          summarise_draws(samples = length, default_convergence_measures())
      )
  ) %>% 
  select(-fit) %>% 
  unnest(out)
f2d %>%  
  kbl(
    caption = "HMC Diagnostics, Model 2c",
    digits = c(0,0,0,2,0,0)
  ) %>% 
  kable_paper(html_font = Font, full_width = FALSE) %>% 
  column_spec(
    4, 
    color = "white",
    background = spec_color(
      f2d$rhat, 
      direction = 1, 
      option = "C", 
      end = .7
    )
  ) %>% 
  scroll_box(height = "600px", width = "800px")
```

```{r}
tmp <- fits_2 %>% 
  mutate(
    out = map(
      fit, 
      ~pp_check(
        .x, 
        ndraws = 10, 
        type = "dens_overlay_grouped",
        group = "region",
        resp = "val", 
        newdata = .x$data
      ) + 
        facet_wrap("group", nrow = 1, scales = "free_y")
    )
  )
wrap_plots(tmp$out, nrow = 3) &
  scale_x_continuous(
    breaks = pretty_breaks(2),
    labels = function(x) percent(x/100, 1)
  )
```

### Summary

We then display the model's population-level parameters

```{r}
tmp <- fits_2 %>% 
  mutate(
    out = map(
      fit, 
      ~as_draws_df(.x, variable = "^b_", regex = TRUE) %>% 
        summarise_draws(
          mean, quantile, rhat, 
          .args = list(probs = c(.025, .975))
        )
    )
  ) %>% 
  select(-fit) %>% 
  unnest(out) %>% 
  mutate(across(where(is.numeric), ~round(., 2))) %>% 
  mutate(
    result = str_glue(
      "b = {mean} ({`2.5%`}, {`97.5%`})"
    )
  ) %>% 
  rowwise() %>% 
  select(-c(mean, `2.5%`, `97.5%`, rhat)) %>% 
  pivot_wider(names_from = cause, values_from = result)
tmp %>%   
  kbl() %>% 
  kable_paper(html_font = Font) 
```

Coefficients

```{r}
tmp <- fits_2 %>% 
  mutate(
    out = map(
      fit, 
      ~emtrends(.x, var = "i1_cw", by = c("sex", "age"))
    )
  ) %>% 
  select(-fit)
tmp %>% 
  mutate(out = map(out, ~as.data.frame(out))) %>% 
  unnest(out) %>% 
  select(cause, sex, age, i1_cw.trend, lower.HPD, upper.HPD) %>% 
  kbl(digits = 3) %>% 
  kable_minimal(full_width = FALSE)
```

## Model 2 for fixed and mobile

```{r}
bf_2_f <- bf(
  val ~ 
    year * sex + year * age + f1_cw * sex + f1_cw * age + f1_cb + 
    (year * sex + year * age + f1_cw * sex + f1_cw * age | country) +
    (year * sex + year * age + f1_cw * sex + f1_cw * age | region),
  family = gaussian()
)

fits_2_f <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit = list(
      brm(
        formula = bf_2_f, 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-2-fixed-{cur_group()}")
      )
    )
  )

bf_2_m <- bf(
  val ~ 
    year * sex + year * age + m1_cw * sex + m1_cw * age + m1_cb + 
    (year * sex + year * age + m1_cw * sex + m1_cw * age | country) +
    (year * sex + year * age + m1_cw * sex + m1_cw * age | region),
  family = gaussian()
)

fits_2_m <- dat %>%
  group_by(cause) %>% 
  summarise(
    fit = list(
      brm(
        formula = bf_2_m, 
        data = cur_data_all(),
        chains = hmc$chains, 
        cores = hmc$cores, 
        threads = hmc$threads,
        iter = hmc$iter, 
        warmup = hmc$warmup, 
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta, 
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("output/brm-2-mobile-{cur_group()}")
      )
    )
  )
```

