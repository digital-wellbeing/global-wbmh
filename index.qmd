---
title: "Adolescent well-being in the digital age"
author: "Matti Vuorre"
execute:
  enabled: true
  cache: true
  warning: false
  message: false
format: 
  html:
    monofont: Fira Code
    font-size: 1.0em
    code-fold: true
toc: true
toc-depth: 4
crossref:
  fig-prefix: Figure
  tbl-prefix: Table
---

```{r document-options, include = FALSE, cache = FALSE}
# knitr options
knitr::opts_chunk$set(
  fig.align = "center",
  cache.lazy = FALSE # Fix large knitr cache
)
```

## Preface

Welcome! This document is the online analysis supplement to *A global study of the association between internet adoption and adolescent mental health and well-being* (Vuorre & Przybylski, [Preprint]() in preparation). It contains all the analyses reported in the manuscript along with supplemental analyses. The source code and the underlying data are on [GitHub](https://github.com/digital-wellbeing/global-wbmh), with an archived permanent copy on [OSF](https://osf.io/ys7m9/).

::: {.callout-note collapse="true"}
### Reproducibility

The analyses were conducted in R, and can be reproduced locally:

1.  Clone the github repo

-   Terminal: `git clone https://github.com/digital-wellbeing/global-wbmh.git`
-   RStudio: File -> New Project -> Version Control -> Git -> use the URL from above

2.  Prepare the R environment

-   Terminal: `Rscript -e "renv::restore()`
-   RStudio: Click renv -> Restore Library in the Packages panel

3.  Render `index.qmd` to `index.html`

-   Install [Quarto](https://quarto.org/docs/getting-started/installation.html) if you don't already have it
-   Terminal: `quarto render index.qmd`
-   RStudio: Open `index.qmd` and click Render

The models take several hours each to run---depending on your local computing resources---and therefore the rendering process can take several days.

If something doesn't work please open an issue at <https://github.com/digital-wellbeing/global-wbmh/issues>.
:::

## Data preparation

Our analyses draw on three sources of data. The Gallup World Poll is a proprietary dataset and includes people's responses to well-being questions across \~160 countries from 2015 to 2021. The Global Burden of Disease dataset consists of mental health indicators across \~200 countries from 2000 to 2019. And finally the International Telecommunications Union dataset has internet adoption metrics across \~200 countries from 2000 to 2020.

In this first section, we load the raw data sets and prepare them for analyses. We first set up the R environment with these packages and settings:

```{r setup, cache = FALSE}

# Packages
library(readxl)
library(knitr)
library(ragg)
library(imputeTS)
library(naniar)
library(scales)
library(janitor)
library(haven)
library(labelled)
library(countrycode)
library(ggtext)
library(dtplyr)
library(lubridate)
library(kableExtra)
library(gtsummary)
library(ggstance)
library(mgcv)
library(brms)
library(cmdstanr)
library(ellipse)
library(ggh4x)
library(tidybayes)
library(ggdist)
library(posterior)
library(parameters)
library(emmeans)
library(broom)
library(kableExtra)
library(tidyverse)

# MCMC settings (ensure at most 12 cores)
ncores <- min(parallel::detectCores(logical = FALSE), 12)
nchains <- 4
options(brms.backend = "cmdstanr")
hmc <- list(
  chains = nchains,
  cores = nchains,
  threads = ncores %/% nchains,
  iter = 2500,
  warmup = 1000,
  refresh = 50,
  adapt_delta = .90,
  max_treedepth = 10
)

# Plotting theme & use this font if available
Font <- "Titillium Web"
theme_set(
  theme_linedraw(
    base_size = 12,
    base_family = Font
  ) +
    theme(
      panel.grid = element_blank(),
      strip.text = element_text(margin = margin(4, 4, 4, 4, "pt"))
    )
)

#' Custom kableExtra formatting
#'
#' @param a table from kbl()
#'
#' @return a table
kable_custom <- function(x) {
  kable_classic(
    kable_input = x,
    html_font = Font,
    font_size = 13,
    lightable_options = "striped",
    position = "center",
    full_width = FALSE
  )
}

# Create directory for intermediate files
dir.create("models", FALSE)
```

### Gallup World Poll

We first prepare the Gallup data. Note that this data set is not publicly available, and therefore not included in our repository. We provide a synthetic mock dataset---loaded below---for users who do not have access to the GWP dataset.

```{r gallup-codebook}
#| echo: false
#| eval: false
# Understand variables & values
# Codes NOTE 1: yes 2: no!
read_spss(
  "data-raw/Gallup/The_Gallup_101521.sav",
  n_max = 1,
  col_select = c(
    WPID, WP1219,
    WP16,
    WP60, WP61, WP63, WP65, WP67,
    WP68, WP69, WP70, WP71, WP74
  )
) %>%
  generate_dictionary()
```

Here we import the relevant variables from Gallup's SPSS files and then

-   Clean the variable names
-   Set appropriate missing values (`NaN`, not e.g. `-99`)
-   Use appropriate coding schemes (e.g. 0: no; 1: yes)
-   Calculate scale scores (means over items)
-   Rescale outcomes to proportions (0 - 1)
-   Subset the data to 15 to 24 year olds
-   Create age-categories in line with GBD data
-   Drop one 13 year old as this data should only have people 15 and older

```{r gallup-clean}
# First liberate the data from the slow SPSS file and save to disk
gwp_path <- "data-raw/Gallup/gwp-processed.rds"
if (!file.exists(gwp_path)) {
  gwp <- read_spss(
    "data-raw/Gallup/The_Gallup_101521.sav",
    col_select = c(
      YEAR_CALENDAR,
      COUNTRYNEW,
      WPID, WP1220, WP1219,
      WP16,
      WP60, WP61, WP63, WP65, WP67,
      WP68, WP69, WP70, WP71, WP74
    )
  )

  # Get rid of SPSS attributes
  gwp <- gwp %>%
    zap_labels() %>%
    zap_label() %>%
    zap_widths() %>%
    zap_formats()

  # Save into a good format
  write_rds(gwp, gwp_path)
} else {
  gwp <- read_rds(gwp_path)
}

gwp <- gwp %>%
  clean_names() %>%
  transmute(
    country = countrynew,
    year = year_calendar,
    id = wpid,
    sex = factor(wp1219, levels = c(2, 1), labels = c("Female", "Male")),
    age = wp1220,
    # Don't know, refused, and missing values
    Life_satisfaction = if_else(between(wp16, 0, 10), wp16, NaN),
    across(wp60:wp74, ~ if_else(between(., 1, 2), ., NaN)),
    # Also reverse the weird 1: yes 2: no coding here
    across(wp60:wp74, ~ 3 - .)
  )

# Scale scores note rescaling
gwp <- gwp %>%
  mutate(
    Life_satisfaction = Life_satisfaction / 10,
    Negative_experiences =
      rowMeans(select(., wp68:wp74), na.rm = TRUE) - 1,
    Positive_experiences =
      rowMeans(select(., wp60:wp67), na.rm = TRUE) - 1
  ) %>%
  select(-c(wp60:wp74))

# Categorize ages
gwp <- gwp %>%
  mutate(
    age = cut(
      age,
      breaks = seq(15, 105, by = 5),
      include.lowest = TRUE,
      right = FALSE,
      labels = paste(seq(15, 100, by = 5), "to", seq(19, 104, by = 5))
    ) %>% as.character()
  )

# There is one 13 year old which resulted in a NA and we drop it
gwp <- drop_na(gwp, age)

# Focus on young people
gwp <- gwp %>%
  filter(age %in% c("15 to 19", "20 to 24"))
```

Instead of working with the person-level scale scores, we aggregate the data to means and standard errors for each cell as defined by the predictors (country, year, age, sex). Because we treat outcomes as normal this greatly simplifies and speeds up the computations without affecting the results, and also makes the data format concordant with the GBD data.

```{r gallup-summarise}
gwp <- gwp %>%
  pivot_longer(
    c(
      Life_satisfaction,
      Negative_experiences,
      Positive_experiences
    ),
    names_to = "outcome", values_to = "val"
  ) %>%
  group_by(country, year, sex, age, outcome) %>%
  summarise(
    se = sd(val, na.rm = TRUE) / sqrt(n()),
    val = mean(val, na.rm = TRUE)
  ) %>%
  ungroup()
```

We have three data sets with information on countries. Unfortunately, they can all use idiosyncratic naming conventions for the countries, and we therefore harmonise the names in each dataset to the same standard values. We use the short English names from the UNICODE CLDR project as provided by `countrycode::countryname()`. We do that here for the GWP data, and check that all countries receive a unique name.

```{r gwp-harmonise-countries}
#| results: hold
#| label: tbl-gwp-countries
#| tbl-cap: "Countries whose original GWP name is different to the harmonised one, or whose harmonised name is missing"
#| layout-ncol: 1

# Check what names were changed and if any don't have harmonised counterpart
gwp %>%
  distinct(country) %>%
  arrange(country) %>%
  mutate(
    country_harmonised = countryname(country, destination = "cldr.short.en")
  ) %>%
  filter(country != country_harmonised | is.na(country_harmonised)) %>%
  kbl(caption = "GWP harmonised country names") %>%
  kable_custom()

# We can see that this would result in North Cyprus being lumped with Cyprus so we need to replace the name before harmonising

# Harmonise old names and replace only if harmonised name found
gwp <- gwp %>%
  mutate(
    country_harmonised = countryname(
      country,
      destination = "cldr.short.en"
    )
  ) %>%
  # This picks the harmonised name if exists, otherwise original name
  # Prevent north cyprus from becoming cyprus
  mutate(
    country_harmonised = ifelse(
      country == "Northern Cyprus",
      "Northern Cyprus",
      country_harmonised
    )
  ) %>%
  mutate(country = coalesce(country_harmonised, country)) %>%
  select(-country_harmonised)
```

### Global Burden of Disease

We downloaded the Global Burden of Disease data from <http://ghdx.healthdata.org/gbd-results-tool> on 2021-11-02 to `data-raw/GBD/`. We include those files in our repository as [permitted by the license](http://ghdx.healthdata.org/): We load all the GBD tables to R. They are inside downloaded `.zip` files, of which there may be more than one.

```{r gbd-data-load}
# Load data files and merge to one table
gbd <- list.files(
  "data-raw/GBD/",
  pattern = ".zip", full.names = TRUE, recursive = TRUE
) %>%
  read_csv()
```

We then clean the GBD data and

-   Clean the variable names
-   Remove the metric and measure variables; we focus on prevalence rate
    -   prevalence: Total number of cases
    -   rate: Total cases per 100,000 population
-   Convert outcome rates to proportions (0 - 1)
-   Clean cause names and rename to outcome to harmonise with GWP
-   Convert GBD estimated rate CI limits to an approximate standard error
-   Subset data to young people (10 - 24)

```{r gbd-data-clean}
# First step is to clean names
gbd <- clean_names(gbd)

# Confirm that correct measures were downloaded:
# distinct(gbd, measure, metric)
gbd <- select(gbd, -metric, -measure)
gbd <- gbd %>%
  mutate(across(c(val, upper, lower), ~ .x / 100000))

# Clean cause names
# distinct(gbd, cause)
gbd <- gbd %>%
  mutate(
    cause = case_when(
      cause == "Anxiety disorders" ~ "Anxiety",
      cause == "Depressive disorders" ~ "Depression",
      cause == "Self-harm" ~ "Selfharm"
    )
  )

# Harmonise variable names with other datasets
gbd <- gbd %>%
  rename(country = location, outcome = cause)

# The outcomes values are model predictions and come with lower and upper CI limits (2.5 and 97.5 %iles of their posterior distributions). We convert those to normal approximate standard errors.
gbd <- gbd %>%
  mutate(se = (upper - lower) / (1.96 * 2)) %>%
  select(-c(upper, lower))

# Focus on young people
gbd <- gbd %>%
  filter(age %in% c("10 to 14", "15 to 19", "20 to 24"))
```

Then we need to harmonise to country names (always somewhat idiosyncratic) to a common metric. There is a harmonised name for each GBD country, and 27 country names are harmonised.

```{r gbd-harmonise-countries}
#| results: hold
#| label: tbl-gbd-countries
#| tbl-cap: "Countries whose original GBD name is different to the harmonised one, or whose harmonised name is missing"
#| layout-ncol: 1

# Check what names were changed and if any don't have harmonised counterpart
gbd %>%
  distinct(country) %>%
  arrange(country) %>%
  mutate(
    country_harmonised = countryname(country, destination = "cldr.short.en")
  ) %>%
  filter(country != country_harmonised | is.na(country_harmonised)) %>%
  kbl(caption = "GBD harmonised country names") %>%
  kable_custom()
# Harmonise old names and replace only if harmonised name found
gbd <- gbd %>%
  mutate(
    country_harmonised = countryname(
      country,
      destination = "cldr.short.en"
    )
  ) %>%
  # This picks the harmonised name if exists, otherwise original name
  mutate(country = coalesce(country_harmonised, country)) %>%
  select(-country_harmonised)
```

### International Telecommunication Union

After processing the outcome tables above, we move on to the internet adoption metrics from the ITU. We downloaded these data files from the ITU website. New versions may be posted subsequent to this, in which case the URLs could be changed here to update the analyses with latest data.

After downloading, we cleaned the ITU data to a shape concordant with the outcome data, and converted the values to proportions (0 - 1). Then we harmonised the country names as above, and dropped countries that don't exist in outcomes.

```{r itu-process}
#| results: hold
#| label: tbl-itu-0
#| tbl-cap: "ITU countries"
#| layout-ncol: 1

# Download data sets from the ITU website if not yet downloaded
if (!file.exists("data-raw/ITU/PercentIndividualsUsingInternet.xlsx")) {
  dir.create("data-raw/ITU")
  download.file(
    "https://www.itu.int/en/ITU-D/Statistics/Documents/statistics/2021/PercentIndividualsUsingInternet_Nov2021.xlsx",
    "data-raw/ITU/PercentIndividualsUsingInternet.xlsx"
  )
  download.file(
    "https://www.itu.int/en/ITU-D/Statistics/Documents/statistics/2021/July/FixedBroadbandSubscriptions_2000-2020.xlsx",
    "data-raw/ITU/FixedBroadbandSubscriptions_2000-2020.xlsx"
  )
  download.file(
    "https://www.itu.int/en/ITU-D/Statistics/Documents/statistics/2021/July/MobileBroadbandSubscriptions_2007-2020.xlsx",
    "data-raw/ITU/MobileBroadbandSubscriptions_2007-2020.xlsx"
  )
}

# Read and reshape fixed broadband data
itu_fixed <- read_xlsx(
  "data-raw/ITU/FixedBroadbandSubscriptions_2000-2020.xlsx",
  sheet = 2,
  col_types = "text"
) %>%
  pivot_longer(-c(Indicator, Country)) %>%
  separate(name, into = c("year", "variable")) %>%
  pivot_wider(names_from = variable) %>%
  mutate(fixed = as.numeric(value)) %>%
  select(country = Country, year, fixed)

# Read and reshape mobile broadband data
itu_mobile <- read_xlsx(
  "data-raw/ITU/MobileBroadbandSubscriptions_2007-2020.xlsx",
  sheet = 2,
  col_types = "text"
) %>%
  pivot_longer(-c(Indicator, Country)) %>%
  separate(name, into = c("year", "variable")) %>%
  pivot_wider(names_from = variable) %>%
  mutate(mobile = as.numeric(value)) %>%
  select(country = Country, year, mobile)

# Percent using internet
itu_percent <- read_xlsx(
  "data-raw/ITU/PercentIndividualsUsingInternet.xlsx",
  col_types = "text"
) %>%
  pivot_longer(-c(Indicator, Country)) %>%
  separate(name, into = c("year", "variable")) %>%
  pivot_wider(names_from = variable) %>%
  mutate(internet = as.numeric(value)) %>%
  select(country = Country, year, internet)

# Merge to one table in wide format (oldest on left to include all years)
itu <- reduce(list(itu_percent, itu_fixed, itu_mobile), left_join)

# values (1-100) to proportions (0-1) and years to numbers
itu <- itu %>%
  mutate(across(c(internet, fixed, mobile), function(x) x / 100)) %>%
  mutate(year = as.numeric(year))

# Drop tables
rm(itu_fixed, itu_mobile, itu_percent)

# Harmonise countries
# Check what names were changed and if any don't have harmonised counterpart
itu %>%
  distinct(country) %>%
  arrange(country) %>%
  mutate(
    country_harmonised = countryname(country, destination = "cldr.short.en")
  ) %>%
  filter(country != country_harmonised | is.na(country_harmonised)) %>%
  kbl(caption = "ITU harmonised country names") %>%
  kable_custom()

# Harmonise old names and replace only if harmonised name found
itu <- itu %>%
  mutate(
    country_harmonised = countryname(
      country,
      destination = "cldr.short.en"
    )
  ) %>%
  # This picks the harmonised name if exists, otherwise original name
  mutate(country = coalesce(country_harmonised, country)) %>%
  select(-country_harmonised)

# Drop countries that don't exist in outcomes
itu <- itu %>%
  filter(
    country %in% unique(gbd$country) | country %in% unique(gwp$country)
  )

# Drop countries that don't have any actual internet data
itu_zeros <- itu %>%
  group_by(country) %>%
  summarise(s = sum(internet, na.rm = TRUE)) %>%
  filter(s == 0)

itu <- itu %>%
  filter(!(country %in% itu_zeros$country))
rm(itu_zeros)
```

#### Missingness

We then impute missing intermediate values to the internet adoption timeseries. We use linear interpolation to fill missing intermediate values, but do not extrapolate before or after the first and last values of each country.

```{r itu-impute}
#| results: hold
#| label: tbl-itu-impute
#| tbl-cap: "Summary of ITU data imputation"

# Reshape to easily impute all variables
itu_long <- itu %>%
  pivot_longer(c(internet, fixed, mobile))

# Impute by country and variable
itu_long <- itu_long %>%
  group_by(country, name) %>%
  # Find first and last year with this variable in each country
  # so as to prevent extrapolation
  mutate(
    min_year = year[min(which(!is.na(value)))],
    max_year = year[max(which(!is.na(value)))]
  ) %>%
  # Interpolate values linearly
  # use possibly() to avoid errors for countries with no data
  mutate(
    across(
      value,
      .fns = list(
        i = possibly(
          function(x) na_interpolation(x, maxgap = Inf),
          otherwise = NaN
        )
      )
    )
  ) %>%
  # Take out projected (non-intermediate) imputed values
  mutate(
    value_i = if_else(
      between(year, unique(min_year), unique(max_year)),
      value_i,
      NaN
    )
  ) %>%
  ungroup() %>%
  select(-min_year, -max_year)

# Summary
itu_long %>%
  group_by(name) %>%
  mutate(min_year = if_else(name == "mobile", 2007, 2000)) %>%
  summarise(
    n_miss_orig = sum(is.na(value) & year >= min_year),
    p_miss_orig = percent(n_miss_orig / sum(year >= min_year), .1),
    n_miss_imp = sum(is.na(value_i) & year >= min_year),
    p_miss_imp = percent(n_miss_imp / sum(year >= min_year), .1),
    imputed = n_miss_orig - n_miss_imp
  ) %>%
  kbl(caption = "ITU data imputation summary") %>%
  kable_custom()


# We then replace the original values with the imputed ones
itu <- itu_long %>%
  # Pick non-missing value, from original and imputed
  mutate(value = coalesce(value, value_i)) %>%
  select(-value_i) %>%
  pivot_wider()
rm(itu_long)
```

### GLOBE regions

We group the countries into GLOBE regions in order to have a higher level of grouping at which the analyses can be summarised. This allows us to eg. present figures and tables per region, instead of overwhelmingly by country, and also provides an upper level for the multilevel models. We use the extended GLOBE regions following Jebb et al. (2020), and had to manually add labels to some countries that were not grouped in those studies.

```{r globe-regions}
#| results: hold
#| label: tbl-globe
#| tbl-cap: "Countries with manually filled region"

regions <- read_csv(
  "data-raw/Regions/GLOBE-regions-from-Jebb-et-al-2020.csv"
) %>%
  # Jebb et al used * to indicate deviance from GLOBE, remove
  mutate(country = str_remove_all(country, "\\*")) %>%
  # Standardize country names
  # This drops Nagorno-Karabakh Republic
  mutate(country = countryname(country)) %>%
  drop_na(country)

# This also combined Swaziland and (Eswatini) to Eswatini, and Northern- and Cyprus. Therefore we just take the distinct country & region.
regions <- distinct(regions, region, country)

# Countries in GBD not present in region data
no_region_gbd <- filter(
  distinct(gbd, country),
  !(country %in% unique(regions$country))
) %>%
  arrange(country)

# Then see what countries in GWP are without region
no_region_gwp <- filter(
  distinct(gwp, country),
  !(country %in% unique(regions$country))
) %>%
  arrange(country)

bind_rows(no_region_gbd, no_region_gwp) %>%
  arrange(country) %>%
  distinct() %>%
  write_csv("data-raw/Regions/countries-without-region.csv")

# I then filled missing regions in Jebb et al and extended GLOBE referenced therein

# Load our manually filled region data
regions_filled <- read_csv(
  "data-raw/Regions/countries-without-region-filled.csv"
)

# Combine Jebb et al GLOBE regions and our manually added ones
regions <- regions %>%
  bind_rows(
    regions_filled %>%
      mutate(Note = "Filled")
  ) %>%
  arrange(region, country)

# Shorter name for plots
regions <- regions %>%
  mutate(region = if_else(region == "Sub-Sahara Africa", "Africa", region))

# Display table of regions and countries
regions %>%
  drop_na(Note) %>%
  select(-Note) %>%
  arrange(region, country) %>%
  kbl(caption = "Countries with a manually filled region") %>%
  kable_custom()

# Clean region labels
regions$region <- str_replace_all(regions$region, " ", "_")
regions$region <- factor(regions$region)

# Remove unnecessary items
regions <- select(regions, -Note)

# Add regions to data tables
itu <- left_join(itu, regions)
gbd <- left_join(gbd, regions)
gwp <- left_join(gwp, regions)
# Remove now unnecessary variables
rm(no_region_gbd, no_region_gwp, regions_filled, regions)
```

### ITU summary table

```{r itu-summary-table}
#| column: page
#| tbl-cap: "Mean internet user percentages across regions and time."
#| label: tbl-itusummary

itu %>%
  select(region, country, year, internet) %>%
  mutate(internet = internet * 100) %>%
  mutate(region = str_replace(region, "_", " ")) %>%
  pivot_wider(names_from = year, values_from = internet) %>%
  select(-country) %>%
  tbl_summary(
    by = region,
    missing = "no",
    statistic = list(all_continuous() ~ "{mean}% ({N_nonmiss})")
  ) %>%
  add_overall(col_label = "Total") %>%
  as_kable_extra(caption = "ITU summary") %>%
  row_spec(0, bold = TRUE) %>%
  kable_custom()
```

## RQ1: Time courses

Our first research question concerns changes in mental health and well-being over time: To what extent has adolescent mental health changed over time (RQ1a)? And, do changes in well-being correlate with changes in internet adoption (RQ1b)? To answer, we estimate a multilevel multivariate model of the outcomes and internet adoption.

### Modelling

We first prepare the variables for modelling:

-   Transform edge values of internet variable to fit beta
    -   2 values were changed (0 in Timor-Leste in 2002, and 1 in UAE 2020)
-   Join outcome and predictor tables
-   Center year on 2010 (roughly in the middle)
-   Ensure that age and sex are treated with contrast codes

```{r model1-prepare-data}
# Transform internet edge cases
itu <- itu %>%
  mutate(internet = if_else(internet == 0, .0000001, internet)) %>%
  mutate(internet = if_else(internet == 1, .9999999, internet))

# Stack outcome data
dat <- bind_rows(gwp, gbd)

# Merge predictors to outcomes
dat <- left_join(dat, itu)

# Center and scale year
dat <- dat %>%
  mutate(year = (year - 2010) / 10)

# Identify values to use in mv models
# Indicate unique ITU values for MV model
dat <- dat %>%
  # Unique values exist for each country-year, but must be given for each
  # outcome
  group_by(region, country, year, outcome) %>%
  mutate(itu = 1:n() == 1) %>%
  ungroup()

# Ensure that factors are contrast coded
dat <- dat %>%
  mutate(across(c(sex, age), factor))
options(contrasts = c(unordered = "contr.sum", ordered = "contr.poly"))

# Model outcomes on the percentage (0-100) scale. Note internet is still 0-1
dat <- dat %>%
  mutate(across(c(val, se), ~ . * 100))

# Arrange on outcome
oo <- c(
  "Life_satisfaction", "Negative_experiences", "Positive_experiences",
  "Anxiety", "Depression", "Selfharm"
)
dat <- dat %>%
  mutate(outcome = factor(outcome, levels = oo)) %>% 
  arrange(dat, outcome, region, country, year)

dat %>%
  group_by(outcome) %>%
  summarise(
    min = min(val, na.rm = TRUE),
    max = max(val, na.rm = TRUE),
    internet_min = min(internet, na.rm = TRUE),
    internet_max = max(internet, na.rm = TRUE)
  ) %>%
  kable(digits = 7) %>% 
  kable_custom()
```

#### Specification

We first tackle RQ1: To what extent did the outcomes change over time (1a), and were changes in outcomes correlated with changes in internet adoption between countries (1b). Model 1, a three-level bayesian meta-regression model, will provide answers, by simultaneously estimating trends over time for the outcome (e.g. Life satisfaction) and internet adoption, with shared covariance matrices over the two outcomes across regions and countries. We also include contrast-coded demographic factors as main effects and moderators, and can therefore examine whether the trends differ between demographic groups (RQ3)

We fit the model separately for each outcome. Although a full multivariate would additionally allow examining correlations in time trends of the outcomes, it is not plausible with the differential groups in the data sets (contrast coded demographic groups would be harder to interpret). We therefore estimate six separate bivariate models

In this model, internet adoption is treated as Beta-distributed and the outcomes are treated as gaussian. All the regression coefficients are allowed to vary randomly across regions and countries, with a shared correlation matrix of the random effects across the two model outcomes. This latter specification is important to allow answering RQ1b.

The GBD data are estimates with standard errors, and thus suggest that a model that incorporates the SEs would be appropriate. For this reason, and for reducing computational complexity, we have reshaped the GWP data similarly to aggregates per cell (mean and SE for each country \* year \* sex \* age). The one downside of this modelling strategy is that it does not converge for self-harm, probably because the means and SEs are highly correlated in those data. Therefore we estimate the model with SEs for all outcomes except self-harm, where we set the SEs to zero, leading to a regular (three-level) regression model.

We write the model as

$$
\begin{align*}
y_i &\sim \text{Normal}(\mu^y_i, \sigma^{2y}v_i) \\
\mu^y_i &= \beta^{y}_{0} + \delta^{y}_{0\text{region}[i]} + 
\gamma^{y}_{0\text{country}[i]} + \\ &(\beta^y_{1} + \delta^{y}_{1\text{region}[i]} + \gamma^{y}_{1\text{country}[i]})\text{Time}_i + 
\\ &(\beta^y_{2} + \delta^{y}_{2\text{region}[i]} + \gamma^{y}_{2\text{country}[i]})\text{Sex}_i + 
\\ &(\beta^y_{3} + \delta^{y}_{3\text{region}[i]} + \gamma^{y}_{3\text{country}[i]})\text{Age}_i + 
\\ &(\beta^y_{4} + \delta^{y}_{4\text{region}[i]} + \gamma^{y}_{4\text{country}[i]})\text{Sex}_i \times \text{Time}_i + 
\\ &(\beta^y_{5} + \delta^{y}_{5\text{region}[i]} + \gamma^{y}_{5\text{country}[i]})\text{Age}_i \times \text{Time}_i \\ \\
x_i &\sim \text{Beta}(\mu^x_i, \phi^x) \\ 
\text{logit}(\mu^x_i) &= \beta^{y}_{0} + \delta^{x}_{0\text{region}[i]} + \gamma^{x}_{0\text{country}[i]} + \\ &(\beta^x_{1} + \delta^{x}_{1\text{region}[i]} + \gamma^{x}_{1\text{country}[i]})\text{Time}_i  \\ \\
\left[\begin{array}{c}
\delta^y_{0\text{region}} \\ \delta^y_{1\text{region}} \\ 
\delta^y_{2\text{region}} \\ \delta^y_{3\text{region}} \\ 
\delta^y_{4\text{region}} \\ \delta^y_{5\text{region}} \\ 
\delta^x_{0\text{region}} \\ \delta^x_{1\text{region}}
\end{array}\right] 
&\sim MVN(
\mathbf{0},
\Sigma^\text{r}
),
\left[\begin{array}{c}
\gamma^y_{0\text{country}} \\ \gamma^y_{1\text{country}} \\ 
\gamma^y_{2\text{country}} \\ \gamma^y_{3\text{country}} \\ 
\gamma^y_{4\text{country}} \\ \gamma^y_{5\text{country}} \\ 
\gamma^x_{0\text{country}} \\ \gamma^x_{1\text{country}}
\end{array}\right] 
\sim MVN(
\mathbf{0},
\Sigma^\text{c}
)
\end{align*}
$$

Where $y_i$ are the outcomes, $x_i$ the internet adoption values, and $v_i$ indicate the known sampling variances.

We then define the model formulas in brms' formula syntax. First, for internet adoption, we take care to indicate that each internet adoption datum should be modelled only once, because the values are repeated in the outcome data table. To do this we use `resp_subset(itu)`, where `itu` indicates first unique rows of ITU data in the model. The `|c|` and `|r|` separating the random effects from their grouping factors indicate shared correlation matrices with other modelled parameters in the model (see the next model formula below).

```{r model1-itu-bf}
# Define a model of internet proportion over year
bf_itu <- bf(
  internet | resp_subset(itu) ~
  year +
    (year |c| country) +
    (year |r| region),
  family = Beta()
)
```

Here, we specify the outcome model. Note the `|c|` and `|r|` that link the countries' and regions', respectively, random effects of this model with the previous' model. Then, we specify `resp_se(se, sigma = TRUE)` to enable "meta-regression" with known standard errors. In addition, it leads to the residual variance to be estimated.

```{r model1-val-bf}
# Meta-regression model of outcomes
bf_1 <- bf(
  val | resp_se(se, sigma = TRUE) ~
  year * sex + year * age +
    (year * sex + year * age | c | country) +
    (year * sex + year * age | r | region),
  family = gaussian()
)
```

Finally, after numerous attempts we were unable to fit a model with meta-analytic standard errors with self-harm as the outcome in a way that would have converged. We therefore effectively removed the SEs from self-harm by setting them to zero

```{r model1-selfharm-se}
dat <- dat %>% 
  mutate(se = if_else(outcome == "Selfharm", 0, se))
```

#### Fitting

We then create a table where each row is a dataset and a model to be fitted, and then fit the models row-by-row. This takes about a day for the six outcomes.

```{r fit-model-1}
fits <- dat %>%
  # Could nest but need this to include group key in nested tibble
  group_by(outcome) %>%
  summarise(data = list(cur_data_all()))

fits <- fits %>%
  mutate(
    fit1 = map2(
      data, outcome,
      ~brm(
        formula = bf_itu + bf_1 + set_rescor(FALSE),
        data = .x,
        chains = hmc$chains,
        cores = hmc$cores,
        threads = hmc$threads,
        iter = hmc$iter,
        warmup = hmc$warmup,
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta,
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("models/brm-{.y}-1-internet")
      )
    )
  )
```

#### Summary

Here is a summary of the data modelled for each outcome

```{r model-1-data-summary}
#| column: body-outset
#| tbl-cap: "Summaries of data included in Model 1"
#| label: tbl-m1-data

#' Model summary
#'
#' @param x a brmsfit
#'
#' @return A tibble with information on data in the model
msum <- function(x) {
  tibble(
    regions = ngrps(x)$region,
    countries = ngrps(x)$country,
    `year/country` = x$data %>%
      distinct(country, year) %>%
      count(country) %>%
      pull(n) %>%
      median(),
    nobs_internet = standata(x)$N_internet,
    nobs_outcome = standata(x)$N_val,
    outcome_range = str_glue(
      "{number(min(x$data$val), .01)} - {number(max(x$data$val), .01)}"
    )
  )
}

fits %>%
  mutate(summary = map(fit1, msum)) %>%
  select(outcome, summary) %>%
  unnest(summary) %>%
  kbl(caption = "Model 1 data summary") %>%
  kable_custom() %>% 
  row_spec(0, bold = TRUE)
```

#### Model checking

Now that the models are fit we proceed to check them. We only do this for the "prototypical" model 1, and so can discard the rest for the rest of this section

##### MCMC diagnostics

First we take a look at numeric summaries of convergence and posterior effective sample sizes. The former should approach 1, the latter should approach the number of hmc iterations.

We can see that the models have converged nicely, apart from the self-harm outcome.

```{r model-1-diagnostics}
#| results: hold
#| label: tab-model1-diagnostic
#| tbl-cap: "HMC Diagnostics, Model 1 population-level regression coefficients and country-level (co)variance parameters."
#| column: body-outset

diagnostic_table <- function(fit, rx, cp) {
  diag_1 <- fits %>%
    select(fit = {{ fit }}, outcome) %>% 
    mutate(
      out =
        map(
          fit,
          ~ as_draws_df(., variable = {{ rx }}, regex = TRUE) %>%
            summarise_draws(samples = length, default_convergence_measures())
        )
    ) %>%
    select(outcome, out) %>%
    unnest(out)
  diag_1 %>%
    kbl(
      caption = cp,
      digits = c(0, 0, 0, 2, 0, 0)
    ) %>%
    column_spec(
      4,
      color = "white",
      background = spec_color(
        log(diag_1$rhat),
        direction = 1,
        option = "C",
        end = .6
      )
    ) %>%
    column_spec(
      c(5, 6),
      color = "white",
      background = spec_color(
        log(diag_1$ess_tail / diag_1$samples),
        direction = 1,
        option = "C",
        end = 0,
        begin = .6
      )
    ) %>%
    kable_custom()
}
diagnostic_table(
  fit1,
  rx = c("^b_", "^sd_", "^cor_country__internet_year__val_year$"),
  cp = "Model 1 MCMC diagnostics."
) %>% 
  scroll_box(height = "300px")
```

##### Posterior predictive check

We then take a coarse look at how well the models reproduce the input data.

```{r ppcheck-density}
#| column: page
#| fig-cap: "Graphical posterior predictive check by region (Model 1). Thin red lines indicate model replicates, whereas the blue lines indicate data; the model is mostly in smooth agreement with data, but has greater discrepancies in some regions (e.g. Anglo Depression)."
#| label: fig-ppcheck-1

ppcheck_1 <- fits %>%
  group_by(outcome) %>%
  mutate(
    out = map(
      fit1,
      ~ pp_check(
        .x,
        ndraws = 10,
        type = "dens_overlay_grouped",
        group = "region",
        resp = "val",
        newdata = .x$data
      )[[1]]
    )
  ) %>%
  ungroup() %>% 
  select(outcome, out) %>%
  unnest(out)

ppcheck_1 %>%
  ggplot(aes(value, col = is_y, alpha = is_y, group = rep_id)) +
  scale_color_brewer(palette = "Set1") +
  scale_alpha_manual(values = c(.2, 1)) +
  stat_density(
    geom = "line",
    size = .75,
    position = position_identity()
  ) +
  labs(x = "Value", y = "Density") +
  facet_grid2(
    outcome ~ group,
    scales = "free", independent = "x",
    labeller = as_labeller(function(x) str_replace(x, "_", "\n"))
  ) +
  theme(
    legend.position = "none",
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  )
rm(ppcheck_1)
```

### Results

#### RQ1a: Temporal trends

Before presenting the time trends, we must calculate the required quantities from the posterior distribution. Here we calculate posterior *samples* of region and average-level trends over time, and posterior *summaries* of trends at all levels.

```{r calculate-simple-effects}
#' Posterior draws at average and region levels
#'
#' @param x brmsfit (model 1/2)
#' @param p name of parameter
#'
#' @return a long tibble posterior draws of p for every region (including the average, so useful for e.g. forest plots)
pdraws <- function(x, p = "val_year") {
  bind_cols(
    tibble("Average" = fixef(x, summary = FALSE)[, p]),
    as_tibble(coef(x, summary = FALSE)$region[, , p])
  ) %>%
    pivot_longer(everything(), names_to = "region")
}

#' Posterior summaries at country- region- and average levels
#'
#' @param x brmsfit (model 1/2)
#' @param p name of parameter
#'
#' @return a long tibble with posterior summary of p at each level
psums <- function(x, p = "val_year") {
  psum_region <- bind_rows(
    fixef(x) %>%
      as.data.frame() %>%
      rownames_to_column("parameter") %>%
      filter(parameter == {{ p }}) %>%
      select(-parameter) %>%
      mutate(region = "Average"),
    coef(x)$region[, , p] %>%
      as.data.frame() %>%
      rownames_to_column("region")
  ) %>%
    as_tibble()

  psum_country <- ranef(x)$country[, , p] %>%
    as.data.frame() %>%
    rownames_to_column("country") %>%
    left_join(distinct(x$data, region, country)) %>%
    as_tibble() %>%
    left_join(select(psum_region, region, r_value = Estimate)) %>%
    mutate(across(Estimate:Q97.5, ~ . + r_value)) %>%
    select(-r_value)

  bind_rows(
    psum_region,
    psum_country
  ) %>%
    mutate(region = fct_relevel(region, "Average"))
}

p_draws <- fits %>%
  mutate(pdraws = map(fit1, pdraws)) %>%
  select(outcome, pdraws) %>%
  unnest(pdraws) %>%
  mutate(region = fct_relevel(region, "Average"))
p_sums <- fits %>%
  mutate(psums = map(fit1, psums)) %>%
  select(outcome, psums) %>%
  unnest(psums) %>%
  mutate(region = fct_relevel(region, "Average"))
p_sums_internet <- fits %>%
  mutate(psums = map(fit1, ~ psums(.x, "internet_year"))) %>%
  select(outcome, psums) %>%
  unnest(psums) %>%
  mutate(region = fct_relevel(region, "Average"))
```

We then display the average ($\beta^y_1$), region- ($\delta^y_1$), and country-level ($\gamma^y_1$) time trend parameters' posterior distributions. Recall the scales of the variables when interpreting the magnitudes: Year is in decades and outcomes are percentages (0-100).

```{r forest-trends}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Forest plot of linear trends in outcomes"
#| label: fig-forest-trends
p_draws %>%
  mutate(is_average = region == "Average") %>%
  ggplot(aes(value, region, fill = is_average)) +
  scale_fill_manual(values = c("dodgerblue1", "dodgerblue4")) +
  scale_alpha_manual(values = c(.4, .8)) +
  geom_vline(xintercept = 0, lty = 2, size = .2) +
  scale_shape_manual(values = c(21, 19)) +
  scale_y_discrete(
    expand = expansion(c(0.01, .1)),
    labels = function(x) {
      if_else(x == "Average", "**Average**", x) %>%
        str_replace("_", " ")
    }
  ) +
  scale_x_continuous(
    "Estimated linear change per decade",
    breaks = pretty_breaks(),
    labels = function(x) percent(x / 100, .01) %>% str_remove("\\.00"),
    expand = expansion(c(.1, .1))
  ) +
  stat_halfeye(
    point_interval = NULL, normalize = "panels",
    height = .75, adjust = 1,
    aes(alpha = is_average)
  ) +
  # Add country points
  geom_point(
    data = p_sums %>%
      drop_na(country) %>%
      mutate(is_average = TRUE),
    aes(x = Estimate), size = 1, col = "dodgerblue1",
    position = position_nudge(0, -0.075), alpha = .4
  ) +
  stat_pointinterval(
    alpha = 1, .width = c(.95),
    interval_size = 1,
    point_size = 1.75,
    fill = "white",
    aes(shape = after_stat(xmin > 0 | xmax < 0)),
    position = position_nudge(0, 0)
  ) +
  geom_richtext(
    data = p_sums %>%
      filter(is.na(country)) %>%
      mutate(is_average = region == "Average") %>%
      mutate(
        across(
          where(is.numeric),
          ~ if_else(
            outcome == "Selfharm",
            percent(. / 100, .001),
            percent(. / 100, .01)
          )
        )
      ),
    family = Font,
    alpha = 1, size = 2.8, hjust = 1, vjust = 0.2,
    fill = NA, label.color = NA,
    aes(
      x = Inf,
      label = str_glue("{Estimate}<br>[{Q2.5}, {Q97.5}]")
    )
  ) +
  facet_wrap(
    "outcome",
    nrow = 2, scales = "free_x",
    labeller = as_labeller(~ str_replace(., "_", " "))
  ) +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_markdown(),
    legend.position = "none"
  )
```

@fig-forest-trends shows, starting from the top left panel, the average (across countries and regions) change in life satisfaction. This change is not credibly different from zero, at the 95% credibility level, and the posterior mean value of change was a 1% increase in life satisfaction per decade. The region-specific changes were likewise not credibly different from zero, apart from the Eastern Europe region that indicated a modest increase in life satisfaction.

Because we modelled regions (and countries) as draws from a multivariate normal prior distribution, the region-specific estimates are shrunk toward the overall mean and therefore less likely to overfit any individual region's data. This means that the model is less likely to report "false alarms", or estimates at the region- and country-levels that indicate false certainty in nonzero changes. Therefore, although there are a large number of change parameters for each individual outcome, we can be fairly certain that the observed change in Eastern Europe is not due to sampling error but represents a real trend in that population.

We observe credible increases in negative experiences in more regions, with notably a \~10% increase per decade in the African region. However, the average change again is not credibly different from zero. Positive experiences had increased, both on average and across 7/10 regions, with very similar changes in Anxiety. Depression and self-harm, on the other hand, had decreased across the board.

In sum these results were somewhat mixed, where some regions showing both increases (e.g. decreased depression) and decreases (increased anxiety) in well-being.

Then to help illustrate the parameters, we draw figures of the fitted lines conditional on the predictors, or so called counterfactual plots.

```{r fitted-trend-country}


#' Get (grand mean) fitted values for countries
#'
#' @param x a brmsfit model 1
#'
#' @return a data frame of fitted values
fitted_country <- function(x) {
  newx <- x$data %>%
    group_by(country, region, outcome, year) %>%
    summarise(val = mean(val, na.rm = TRUE)) %>%
    ungroup() %>%
    mutate(sex = NA, age = NA, se = 0)
  newy <- bind_cols(
    newx,
    as.data.frame(fitted(x, newdata = newx, resp = "val"))
  ) %>%
    select(-outcome)
  newy
}

f_country <- fits %>%
  mutate(fc = map(fit1, fitted_country)) %>%
  select(outcome, fc)

#' Draw a panel plot of countries' fitted values and data
#'
#' @param x fitted country level data from fitted_country()
#' @param y outcome
#'
#' @return a ggplot for that outcome
plot_country <- function(x, y) {
  coefs <- p_sums %>%
    drop_na(country) %>%
    filter(outcome == y) %>%
    select(country, coef = Estimate, coef.l = Q2.5, coef.u = Q97.5) %>%
    mutate(country = fct_reorder(country, coef))
  x %>%
    left_join(coefs) %>%
    mutate(country = fct_reorder(country, coef)) %>%
    ggplot(aes(make_date(year * 10 + 2010), Estimate)) +
    scale_x_date("Year", date_breaks = "5 years", date_labels = "'%y") +
    scale_y_continuous(
      str_replace(y, "_", " "),
      breaks = pretty_breaks(),
      expand = expansion(.15),
      labels = function(x) {
        percent(x / 100, .01) %>%
          str_remove("\\.00")
      }
    ) +
    # Add parameters in text
    geom_richtext(
      data = coefs %>%
        mutate(across(where(is.numeric), ~ number(., .01))),
      aes(
        x = make_date(2000), y = Inf,
        label = str_glue("{coef}<br>[{coef.l}, {coef.u}]")
      ),
      size = 2.4, vjust = 1, hjust = 0.05, color = "black",
      family = Font,
      fill = alpha("white", .3), label.color = NA,
      label.padding = unit(c(0.1, 0.1, 0.1, 0.1), "lines")
    ) +
    geom_point(aes(y = val), shape = 1, alpha = .5) +
    geom_ribbon(
      aes(ymin = Q2.5, ymax = Q97.5),
      alpha = .3, col = NA, fill = "dodgerblue1"
    ) +
    geom_line(
      size = 0.5, col = "dodgerblue1"
    ) +
    facet_wrap(
      "country"
    ) +
    theme(panel.spacing = unit(2, "pt"))
}

# Create the plot for each outcome
f_country <- f_country %>%
  mutate(
    plot = map2(
      fc, outcome,
      ~ plot_country(.x, .y)
    )
  )
```

::: {.panel-tabset .column-screen-inset-shaded}
##### All outcomes

```{r trends-regions}
#| echo: false
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Trends in all variables across regions"
#| label: fig-trends-regions

# Stack data sets
# Assume all outcomes are proportions (0-1)
dat_all <- bind_rows(
  gwp,
  gbd,
  itu %>% mutate(outcome = "Internet", val = internet)
) %>%
  mutate(outcome = fct_inorder(str_replace(outcome, "_", "_"))) %>%
  group_by(region, country, year, outcome) %>%
  summarise(mean = mean(val, na.rm = TRUE)) %>%
  ungroup()

# Draw small multiples figure, outcomes x regions
dat_all %>% 
  mutate(year = make_date(year)) %>%
  ggplot(aes(year, mean)) +
  scale_y_continuous(
    "Value",
    labels = function(x) percent(x, .01) %>% str_remove("\\.00"),
    breaks = pretty_breaks()
  ) +
  scale_x_date(
    "Year",
    date_breaks = "5 years",
    date_labels = "'%y",
    expand = expansion(.02)
  ) +
  geom_line(
    aes(group = interaction(country, outcome)),
    alpha = .25, size = .4, color = "dodgerblue1"
  ) +
  stat_summary(
    fun = mean, geom = "line",
    size = .6, color = "dodgerblue4"
  ) +
  facet_grid(
    outcome ~ region,
    scales = "free_y",
    labeller = as_labeller(function(x) str_replace(x, "_", "\n"))
  ) +
  theme(
    aspect.ratio = 1,
    legend.position = "none",
    panel.spacing = unit(3, "pt"),
    axis.title.y = element_blank()
  )
```

##### Life satisfaction

```{r trends-ls}
#| echo: false
#| fig-width: 16
#| fig-height: 12
#| fig-cap: "Life satisfaction trends, ordered by association magnitude"
#| label: fig-trends-ls
f_country$plot[[1]]
```

##### Negative experiences

```{r trends-ne}
#| echo: false
#| fig-width: 16
#| fig-height: 12
#| fig-cap: "Negative experiences trends, ordered by association magnitude"
#| label: fig-trends-ne
f_country$plot[[2]]
```

##### Positive experiences

```{r trends-pe}
#| echo: false
#| fig-width: 16
#| fig-height: 12
#| fig-cap: "Positive experiences trends, ordered by association magnitude"
#| label: fig-trends-pe
f_country$plot[[3]]
```

##### Anxiety

```{r trends-anx}
#| echo: false
#| fig-width: 16
#| fig-height: 12
#| fig-cap: "Anxiety trends, ordered by association magnitude"
#| label: fig-trends-anx
f_country$plot[[4]]
```

##### Depression

```{r trends-dep}
#| echo: false
#| fig-width: 16
#| fig-height: 12
#| fig-cap: "Depression trends, ordered by association magnitude"
#| label: fig-trends-dep
f_country$plot[[5]]
```

##### Self-harm

```{r trends-sel}
#| echo: false
#| fig-width: 16
#| fig-height: 12
#| fig-cap: "Self-harm trends, ordered by association magnitude"
#| label: fig-trends-sel
f_country$plot[[6]]
```
:::

#### RQ1b: Correlations

We then turned to research question 1b: To what extent were changes in well-being and internet adoption correlated across countries.

To investigate we examined the correlations between $\gamma^y_1$ and $\gamma^x_1$ ($\sigma_{\gamma^y_1,\gamma^x_1}$ in $\Sigma^{\text{c}}$). A positive correlation would indicate that countries with greater increases in internet adoption between 2000 and 2020 would tend to have greater increases in $y$ (e.g. Life satisfaction).

To answer, we display $\sigma_{\gamma^y_1,\gamma^x_1}$ from each outcome's model in the figure below. The figures are scatterplots of country-level trend coefficients, where each point's x-y coordinate indicate their trend magnitudes. The overlaid ellipses are the model's 95% predictive limits for $\gamma^y_1$ and $\gamma^x_1$.

```{r scatterplot-time-internet}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Scatterplots of country-level internet and outcome trends."
#| label: fig-trend-scatterplot

# Correlation parameters
cor_pars <- fits %>%
  mutate(
    out = map(
      fit1,
      ~ as_draws_df(
        .x,
        variable = "cor_country__internet_year__val_year"
      ) %>%
        summarise_draws(mean, sd, ~ quantile2(., probs = c(.025, .975)))
    )
  ) %>%
  select(outcome, out) %>%
  unnest(out) %>%
  mutate(across(where(is.numeric), ~ number(., .01)))

# Ellipses
ellipses <- fits %>%
  mutate(
    ellipse = map(
      fit1,
      ~ as_draws_df(
        .x,
        c(
          "b_val_year",
          "b_internet_year",
          "sd_country__val_year",
          "sd_country__internet_year",
          "cor_country__internet_year__val_year"
        )
      ) %>%
        slice_sample(n = 100) %>%
        rename(
          cor = cor_country__internet_year__val_year,
          sd_outcome = sd_country__val_year,
          sd_i = sd_country__internet_year,
          b_outcome = b_val_year,
          b_i = b_internet_year
        ) %>%
        mutate(
          e = pmap(
            list(cor, sd_outcome, sd_i, b_outcome, b_i),
            function(cor, sd_a, sd_i, b_a, b_i) {
              ellipse(
                cor,
                scale = c(sd_i, sd_outcome),
                centre = c(b_i, b_outcome),
                level = .95
              ) %>%
                as_tibble()
            }
          )
        ) %>%
        unnest(e)
    )
  )
ellipses <- ellipses %>%
  select(outcome, ellipse) %>%
  unnest(ellipse)

# Wide tibble of parameters
left_join(
  p_sums %>%
    drop_na(country) %>%
    rename_with(~ str_glue("Outcome_{.}"), .cols = c(Estimate:Q97.5)),
  p_sums_internet %>%
    drop_na(country) %>%
    rename_with(~ str_glue("Internet_{.}"), .cols = c(Estimate:Q97.5))
) %>%
  ggplot(aes(Internet_Estimate, Outcome_Estimate)) +
  geom_vline(xintercept = 0, lty = 2, size = .2) +
  geom_hline(yintercept = 0, lty = 2, size = .2) +
  geom_path(
    data = ellipses,
    aes(x = x, y = y, group = .draw),
    alpha = .2, size = .1, col = "dodgerblue2"
  ) +
  geom_point(col = "dodgerblue1", size = 1, alpha = .5) +
  scale_y_continuous(
    "Outcome trend",
    breaks = pretty_breaks(),
    labels = function(x) percent(x / 100, .01) %>% str_remove("\\.00")
  ) +
  scale_x_continuous(
    "Internet trend",
    breaks = pretty_breaks()
  ) +
  geom_text(
    data = cor_pars,
    aes(x = -Inf, y = Inf, label = str_glue("{mean} [{q2.5}, {q97.5}]")),
    vjust = 1.3, hjust = -0.025, family = Font
  ) +
  facet_wrap(
    "outcome",
    scales = "free_y",
    labeller = as_labeller(~ str_replace(., "_", " "))
  ) +
  theme(aspect.ratio = 1)
```

#### Other results from Model 1

##### Shrinkage

It's important to note that at the level of countries and regions, the model parameters refer to country^\*^ and region^\*^, that is as they are in the sample of other countries and regions. This modelling strategy is important because it allows describing the parameters at each level while adjusting the values toward the group means (preventing "false alarms"). However it is then important to examine those values against their "fixed effect" counterparts, which we do here.

```{r shrinkage}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Scatterplots of multilevel and independent model coefficients"
#| label: fig-trend-shrinkage

lm_coefs <- fits %>%
  mutate(
    data = map(fit1, ~ as_tibble(.x$data))
  ) %>%
  mutate(
    fit_val = map(
      data,
      ~ tidy(
        lm(val ~ 0 + country + year:country, data = .x)
      )
    ),
    fit_internet = map(
      data,
      ~ tidy(
        gam(
          internet ~ 0 + country + year:country,
          family = betar, data = .x %>%
            filter(itu)
        ),
        parametric = TRUE
      )
    )
  )
lm_coefs <- lm_coefs %>%
  select(outcome, fit_val, fit_internet) %>%
  pivot_longer(c(fit_val, fit_internet)) %>%
  mutate(name = str_remove(name, "fit_")) %>%
  unnest(value) %>%
  select(outcome, name, term, estimate, std.error) %>%
  filter(str_detect(term, ":")) %>%
  mutate(term = str_remove(term, "country")) %>%
  mutate(term = str_remove(term, ":year")) %>%
  pivot_wider(names_from = name, values_from = c(estimate, std.error)) %>%
  rename(country = term)

# Plot
left_join(
  p_sums %>%
    drop_na(country) %>%
    rename_with(~ str_glue("Outcome_{.}"), .cols = c(Estimate:Q97.5)),
  p_sums_internet %>%
    drop_na(country) %>%
    rename_with(~ str_glue("Internet_{.}"), .cols = c(Estimate:Q97.5))
) %>%
  left_join(lm_coefs) %>%
  mutate(region = str_replace(region, "_", " ")) %>%
  ggplot(aes(Internet_Estimate, Outcome_Estimate, col = region)) +
  geom_vline(xintercept = 0, lty = 2, size = .2) +
  geom_hline(yintercept = 0, lty = 2, size = .2) +
  geom_segment(
    aes(
      x = estimate_internet, xend = Internet_Estimate,
      y = estimate_val, yend = Outcome_Estimate
    ),
    arrow = arrow(type = "closed", length = unit(3, "pt")),
    size = .25, show.legend = FALSE
  ) +
  geom_point(size = 1.1, alpha = .4) +
  scale_y_continuous(
    "Outcome trend",
    breaks = pretty_breaks(),
    labels = function(x) percent(x / 100, .01) %>% str_remove("\\.00")
  ) +
  scale_x_continuous(
    "Internet trend",
    breaks = pretty_breaks()
  ) +
  facet_wrap(
    "outcome",
    scales = "free_y",
    labeller = as_labeller(function(x) str_replace(x, "_", "\n"))
  ) +
  guides(
    color = guide_legend(override.aes = list(size = 2, alpha = 1))
  ) +
  theme(
    aspect.ratio = 1,
    legend.position = "bottom"
  )
```

## RQ2: Associations

We then turned to the second research question: To what extent are changes in well-being predicted by internet adoption? To answer, we expand Model 1 to include the country-specific 1-year-lagged internet adoption values (both within- and between country centred) as predictors of the outcomes. Before modelling, we calculated these quantities as shown in this code block.

```{r model2-data-prepare}
# Create lagged predictors
dat <- dat %>% 
  arrange(outcome, region, country, year) %>%
  group_by(outcome, region, country, sex, age) %>%
  mutate(
    across(
      c(internet, fixed, mobile),
      list(`1` = ~ lag(., 1)),
      .names = "{str_sub(.col, 1, 1)}{.fn}"
    )
  ) %>% 
  ungroup()

# Centering predictors within and between countries
dat <- dat %>%
  group_by(outcome, country) %>%
  mutate(
    i1_cb = mean(i1, na.rm = TRUE), # Country average
    i1_cw = i1 - i1_cb, # Year-specific deviation from country average
    f1_cb = mean(f1, na.rm = TRUE),
    f1_cw = f1 - f1_cb,
    m1_cb = mean(m1, na.rm = TRUE),
    m1_cw = m1 - m1_cb,
  ) %>%
  group_by(outcome) %>% 
  # Grand-mean center the country averages
  mutate(
    across(c(i1_cb, f1_cb, m1_cb), ~ . - mean(., na.rm = T))
  )
```

### Specification and fitting

Model 2 was similar to Model 1, but the internet outcome was dropped, and the regression equation for outcomes expanded to include the lagged internet predictor and its two-way interactions


$$\begin{align*}
y_i &\sim \text{Normal}(\mu_i, \sigma^2v_i) \\

\mu_i &= \beta_{0} + \delta_{0\text{region}[i]} + 
\gamma_{0\text{country}[i]} + \\ &(\beta_{1} + \delta_{1\text{region}[i]} + \gamma_{1\text{country}[i]})\text{Time}_i + 
\\ &(\beta_{2} + \delta_{2\text{region}[i]} + \gamma_{2\text{country}[i]})\text{Sex}_i + 
\\ &(\beta_{3} + \delta_{3\text{region}[i]} + \gamma_{3\text{country}[i]})\text{Age}_i + 
\\ &(\beta_{4} + \delta_{4\text{region}[i]} + \gamma_{4\text{country}[i]})\text{Sex}_i \times \text{Time}_i + 
\\ &(\beta_{5} + \delta_{5\text{region}[i]} + \gamma_{5\text{country}[i]})\text{Age}_i \times \text{Time}_i +
\\ &(\beta_{6} + \delta_{6\text{region}[i]} + \gamma_{6\text{country}[i]})\text{Internet}^{\text{t-1}}_i + 
\\ &(\beta_{7} + \delta_{7\text{region}[i]} + \gamma_{7\text{country}[i]})\text{Sex}_i \times \text{Internet}^{\text{t-1}}_i + 
\\ &(\beta_{8} + \delta_{8\text{region}[i]} + \gamma_{8\text{country}[i]})\text{Sex}_i \times \text{Internet}^{\text{t-1}}_i\\ \\

\left[\begin{array}{c}
\delta_{0\text{region}} \\ \delta_{1\text{region}} \\ 
\delta_{2\text{region}} \\ \delta_{3\text{region}} \\ 
\delta_{4\text{region}} \\ \delta_{5\text{region}} \\ 
\delta_{6\text{region}} \\ \delta_{7\text{region}} \\ 
\delta_{8\text{region}}
\end{array}\right] 
&\sim MVN(
\mathbf{0},
\Sigma^\text{r}
),
\left[\begin{array}{c}
\gamma_{0\text{country}} \\ \gamma_{1\text{country}} \\ 
\gamma_{2\text{country}} \\ \gamma_{3\text{country}} \\ 
\gamma_{4\text{country}} \\ \gamma_{5\text{country}} \\ 
\gamma_{6\text{country}} \\ \gamma_{7\text{country}} \\ 
\gamma_{8\text{country}}
\end{array}\right] 
\sim MVN(
\mathbf{0},
\Sigma^\text{c}
)
\end{align*}$$

```{r fit-model-2}

# Model formula is only a small update to Model 1
bf_2 <- bf(
  val | resp_se(se, sigma = TRUE) ~
  year * sex + year * age + i1_cw * sex + i1_cw * age + i1_cb +
    (year * sex + year * age + i1_cw * sex + i1_cw * age | country) +
    (year * sex + year * age + i1_cw * sex + i1_cw * age | region),
  family = gaussian()
)

# As above with model 1
fits <- fits %>%
  mutate(
    fit2 = map2(
      data, outcome,
      ~brm(
        formula = bf_2,
        data = .x,
        chains = hmc$chains,
        cores = hmc$cores,
        threads = hmc$threads,
        iter = hmc$iter,
        warmup = hmc$warmup,
        refresh = hmc$refresh,
        control = list(
          adapt_delta = hmc$adapt_delta,
          max_treedepth = hmc$max_treedepth
        ),
        file = str_glue("models/brm-{.y}-2-internet")
      )
    )
  )
```

### Results

First, we compared the R2 values between Models 1 and 2. This comparison is not perfect because the datasets differed slightly (each country had at least 1 fewer values in Model 2 because of the inclusion of the lagged internet predictor in Model 2). However it gives a rough idea of the added explanatory power of internet adoption on the well-being outcomes.

```{r model21-compare}
#| results: hold
#| tbl-cap: "Model 1 and 2 proportions variance explained by outcome"
#| label: tbl-m12-r2
fits %>%
  select(outcome, fit1, fit2) %>% 
  pivot_longer(c(fit1, fit2)) %>% 
  mutate(
    r2 = map(
      value,
      ~ bayes_R2(., resp = "val") %>%
        as.data.frame() %>%
        mutate(across(everything(), ~ percent(., .1))) %>%
        transmute(result = str_glue("{Estimate} [{Q2.5}, {Q97.5}]"))
    )
  ) %>%
  select(-value) %>%
  unnest(r2) %>% 
  pivot_wider(
    names_from = name,
    values_from = result,
    names_prefix = "Model "
  ) %>%
  mutate(outcome = str_replace(outcome, "_", " ")) %>%
  kbl(caption = "Model 1 and 2 R-squared values") %>%
  kable_custom()
```

Before we can present the results, we calculate the "internet effect" at each of three levels of analysis; the average, region, and country-level.

```{r model2-calculate-coefficients}
p_draws <- fits %>%
  mutate(pdraws = map(fit2, ~pdraws(.x, "i1_cw"))) %>%
  select(outcome, pdraws) %>%
  unnest(pdraws)

p_sums <- fits %>%
  mutate(psums = map(fit2, ~psums(.x, "i1_cw"))) %>%
  select(outcome, psums) %>%
  unnest(psums)

p_draws <- p_draws %>%
  mutate(region = fct_relevel(region, "Average")) %>%
  mutate(outcome = str_replace(outcome, "_", " ")) %>%
  mutate(outcome = factor(outcome, levels = str_replace(oo, "_", " ")))
p_sums <- p_sums %>%
  mutate(region = fct_relevel(region, "Average")) %>%
  mutate(outcome = str_replace(outcome, "_", " ")) %>%
  mutate(outcome = factor(outcome, levels = str_replace(oo, "_", " ")))
```

We then display summaries of the parameters' posterior distributions as forest plots, like above. Recall the scales of the variables: Internet adoption is a proportion (0-1), and outcomes are percentages (0-100).

```{r forest-internet}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Forest plot of internet associations"
#| label: fig-forest-internet
p_draws %>%
  mutate(is_average = region == "Average") %>%
  ggplot(aes(value, region, fill = is_average)) +
  scale_fill_manual(values = c("dodgerblue1", "dodgerblue4")) +
  scale_alpha_manual(values = c(.4, .8)) +
  geom_vline(xintercept = 0, lty = 2, size = .2) +
  scale_shape_manual(values = c(21, 19)) +
  scale_y_discrete(
    expand = expansion(c(0.01, .1)),
    labels = function(x) {
      if_else(x == "Average", "**Average**", x) %>%
        str_replace("_", " ")
    }
  ) +
  scale_x_continuous(
    "Conditional effect of 100% increase in internet adoption on outcome",
    breaks = pretty_breaks(),
    labels = function(x) percent(x / 100, .01) %>% str_remove("\\.00"),
    expand = expansion(c(.1, .1))
  ) +
  stat_halfeye(
    point_interval = NULL, normalize = "panels",
    height = .75, adjust = 1,
    aes(alpha = is_average)
  ) +
  # Add country points
  geom_point(
    data = p_sums %>%
      drop_na(country) %>%
      mutate(is_average = TRUE),
    aes(x = Estimate), size = 1, col = "dodgerblue1",
    position = position_nudge(0, -0.075), alpha = .4
  ) +
  stat_pointinterval(
    alpha = 1, .width = c(.95),
    interval_size = 1,
    point_size = 1.75,
    fill = "white",
    aes(shape = after_stat(xmin > 0 | xmax < 0)),
    position = position_nudge(0, 0)
  ) +
  geom_richtext(
    data = p_sums %>%
      filter(is.na(country)) %>%
      mutate(is_average = region == "Average") %>%
      mutate(
        across(
          where(is.numeric),
          ~ if_else(
            outcome == "Selfharm",
            percent(. / 100, .001),
            percent(. / 100, .01)
          )
        )
      ),
    family = Font,
    alpha = 1, size = 2.8, hjust = 1, vjust = 0.2,
    fill = NA, label.color = NA,
    aes(
      x = Inf,
      label = str_glue("{Estimate}<br>[{Q2.5}, {Q97.5}]")
    )
  ) +
  facet_wrap(
    "outcome",
    nrow = 2, scales = "free_x"
  ) +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_markdown(),
    legend.position = "none"
  )
x <- percent(fixef(fits$fit2[[1]])["i1_cw",-2]/100)
x2 <- percent(hypothesis(fits$fit2[[3]], "i1_cw > 0")$hypothesis$Post.Prob, .1)
```

This figure shows that, on the whole, the predictive associations between internet adoption and well-being were somewhat small. First, on average across regions and countries, a 100% increase in internet adoption was associated with a `r x[1]` increase in life satisfaction, but with 95% confidence this number could range from `r x[2]` to `r x[3]`. However, in the African region, increased internet adoption was associated with increases in life satisfaction at a confidence level exceeding 95%. Somewhat confusingly, internet adoption was positively associated with negative experiences also in the African region. However, none of the average associations were credibly different from zero. The association between internet adoption and positive experiences came closest with a `r x2` posterior probability of a positive association.

To help illustrate the magnitudes of associations, we draw figures of the fitted lines, or so called counterfactual plots.

```{r model2-fitted-values}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Counterfactual plot of internet associations"
#| label: fig-fitted-internet

fitted_country <- function(x) {
  newx <- x$data %>%
    group_by(country) %>%
    mutate(
      xmin = min(i1_cw, na.rm = TRUE),
      xmax = max(i1_cw, na.rm = TRUE)
    ) %>%
    filter(i1_cw %in% c(xmin, xmax)) %>%
    ungroup() %>%
    distinct(country, region, outcome, i1_cw, i1_cb) %>%
    mutate(year = 0, sex = NA, age = NA, se = 0)
  newy <- bind_cols(newx, as.data.frame(fitted(x, newdata = newx))) %>%
    select(-outcome)
  newy
}

fitted_region <- function(x) {
  newx <- x$data %>%
    group_by(outcome, region) %>%
    summarise(i1_cb = mean(i1_cb, na.rm = TRUE)) %>%
    crossing(i1_cw = seq(-.4, .4, length = 10)) %>%
    mutate(year = 0, sex = NA, age = NA, se = 0)

  newy <- bind_cols(
    newx,
    as.data.frame(
      fitted(
        x, 
        newdata = newx, 
        re_formula = ~ 
          (year * sex + year * age + i1_cw * sex + i1_cw * age | region)
        )
    )
  ) %>%
    select(-outcome)
  newy
}

f_country <- fits %>%
  mutate(fc = map(fit2, fitted_country)) %>%
  select(outcome, fc) %>%
  unnest(fc)

f_region <- fits %>%
  mutate(fr = map(fit2, fitted_region)) %>%
  select(outcome, fr) %>%
  unnest(fr)

f_country %>%
  ggplot(aes(i1_cw, Estimate)) +
  scale_x_continuous(
    "Previous year's internet adoption relative to country average in 2000-2020",
    breaks = c(-.35, 0, .35),
    labels = function(x) percent(x, 1)
  ) +
  scale_y_continuous(
    "Estimate",
    breaks = pretty_breaks(),
    labels = function(x) percent(x / 100, .01) %>% str_remove("\\.00")
  ) +
  geom_blank() +
  geom_ribbon(
    data = f_region,
    aes(ymin = Q2.5, ymax = Q97.5),
    alpha = .15, fill = "dodgerblue4"
  ) +
  geom_line(
    data = f_region,
    col = "dodgerblue4", size = .6
  ) +
  geom_line(
    aes(group = country),
    size = .4, alpha = .35, col = "dodgerblue1"
  ) +
  facet_grid(
    outcome ~ region,
    scales = "free_y",
    labeller = as_labeller(function(x) str_replace(x, "_", "\n"))
  ) +
  theme(
    panel.spacing = unit(2, "pt"),
    axis.title.y = element_blank()
  )
```

### Other results from Model 2

We then focused on the between-country association between internet adoption and well-being. Recall that the model does not adjust for between-country differences so these associations are likely to reflect many other factors covarying with internet adoption (e.g. wealth and development factors).

```{r}
#| column: page
#| fig.width: 8
#| fig.height: 6
#| fig-cap: "Between-country associations"
#| label: fig-cb1

fitted_cb1 <- function(x) {
  newx <- x$data %>%
    group_by(outcome, region, country) %>%
    summarise(i1_cb = unique(i1_cb), val = mean(val, na.rm = TRUE)) %>% 
    mutate(i1_cw = 0, year = 0, sex = NA, age = NA, se = 0) %>% 
    ungroup()

  newy <- bind_cols(
    newx,
    as.data.frame(
      fitted(
        x, 
        newdata = newx, 
        re_formula = NA
        )
    )
  ) %>%
    select(-outcome)
  newy
}
tmp <- fits %>% 
  mutate(out = map(fit2, fitted_cb1)) %>% 
  select(outcome, out) %>%
  unnest(out)

cb1_pars <- fits %>%
  mutate(
    out = map(
      fit2,
      ~ as_draws_df(
        .x,
        variable = "b_i1_cb"
      ) %>%
        summarise_draws(mean, sd, ~ quantile2(., probs = c(.025, .975)))
    )
  ) %>%
  select(outcome, out) %>%
  unnest(out) %>%
  mutate(across(where(is.numeric), ~ number(., .01)))

tmp %>% 
  ggplot(aes(i1_cb, val)) +
  scale_x_continuous(
    "Between-country centered internet adoption",
    labels = ~percent(.)
  ) +
  scale_y_continuous(
    "Value",
    labels = ~percent(./100)
  ) +
  geom_point(
    shape = 1, size = 1, alpha = .75
  ) +
  geom_ribbon(
    aes(ymin = Q2.5, ymax = Q97.5),
    fill = "dodgerblue2",
    alpha = .2
    ) +
  geom_line(aes(y = Estimate), col = "dodgerblue4") +
  geom_text(
    data = cb1_pars,
    aes(x = -Inf, y = Inf, label = str_glue("{mean} [{q2.5}, {q97.5}]")),
    vjust = 1.3, hjust = -0.025, family = Font
  ) +
  facet_wrap(
    "outcome",
    scales = "free_y", nrow = 2,
    labeller = as_labeller(~str_replace(., "_", " "))
  ) +
  theme(
    aspect.ratio = 1,
    axis.title.y = element_blank()
  )
```

## RQ3: Demographics

We then turn to the third research question, to what extent are the changes in well-being, and associations between internet adoption and well-being different between the different demographic groups within adolescents? To answer, Models 1 and 2 also included age and sex as moderators of the trends and associations. In this section, we present results based on the moderated effects.

### Trends

```{r model1-demographics}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Forest plot of linear trends in outcomes by demographic group"
#| label: fig-forest-trends-demo
h_gwp <- c(
  `15 to 19` =
    "val_year + val_year:age1 * 1 = 0",
  `20 to 24` =
    "val_year + val_year:age1 * -1 = 0",
  `Female` =
    "val_year + val_year:sex1 * 1 = 0",
  `Male` =
    "val_year + val_year:sex1 * -1 = 0"
)
h_gbd <- c(
  `10 to 14` =
    "val_year + val_year:age1 * 1 + val_year:age2 * 0 = 0",
  `15 to 19` =
    "val_year + val_year:age1 * 0 + val_year:age2 * 1 = 0",
  `20 to 24` =
    "val_year + val_year:age1 * -1 + val_year:age2 * -1 = 0",
  `Female` =
    "val_year + val_year:sex1 * 1 = 0",
  `Male` =
    "val_year + val_year:sex1 * -1 = 0"
)
#' Calculate posterior draws for simple effects (by sex and age) for regions and average
#'
#' @param x brmsfit model 2
#' @param h a brmshypothesis
#'
#' @return a long tibble of draws of posterior answers to hypothesis
simple_effects_samples <- function(x, h) {
  # Calculate hypotheses at average level
  average_h <- hypothesis(
    x, h
  )
  # Give hypotheses appropriate names
  average <- average_h$samples
  names(average) <- interaction(
    "Average", average_h$hypothesis$Hypothesis,
    sep = "+"
  )
  # Pivot to long format, note use of dtplyr
  average <- average %>%
    lazy_dt() %>%
    pivot_longer(everything()) %>%
    separate(name, into = c("region", "Hypothesis"), sep = "\\+") %>%
    as_tibble()

  # Regions as above
  region_h <- hypothesis(
    x, h,
    scope = "coef", group = "region"
  )
  region <- region_h$samples
  names(region) <- interaction(
    region_h$hypothesis$Group,
    region_h$hypothesis$Hypothesis,
    sep = "+"
  )
  region <- region %>%
    lazy_dt() %>%
    pivot_longer(everything()) %>%
    separate(name, into = c("region", "Hypothesis"), sep = "\\+") %>%
    as_tibble()

  bind_rows(average, region)
}

#' Posterior summaries of country- region- and average-level effects for the demographic groups
#'
#' @param x brmsfit model 2
#' @param h character vector of hypotheses
#'
#' @return
simple_effects_summary <- function(x, h) {

  # Calculate hypotheses at average level
  average <- hypothesis(x, h)$hypothesis %>% as_tibble()
  average$region <- "Average"

  # Regions as above
  region <- hypothesis(
    x, h,
    scope = "coef", group = "region"
  )$hypothesis %>%
    as_tibble()
  region <- rename(region, region = Group)

  # Country hypotheses
  country <- hypothesis(
    x, h,
    scope = "ranef", group = "country"
  )
  country <- country$hypothesis %>% as_tibble()
  country <- rename(country, country = Group)

  # Add region coefs
  country <- left_join(country, distinct(x$data, region, country))
  region_coef <- region %>%
    select(region, Hypothesis, r_region = Estimate)
  country <- country %>%
    left_join(region_coef) %>%
    mutate(across(c(Estimate, CI.Lower, CI.Upper), ~ . + r_region)) %>%
    select(-r_region)

  bind_rows(average, region, country)
}

sexage_draws <- fits %>%
  mutate(h = list(h_gwp, h_gwp, h_gwp, h_gbd, h_gbd, h_gbd)) %>%
  mutate(
    samples = map2(
      fit1, h,
      ~ simple_effects_samples(.x, .y)
    )
  ) %>%
  select(outcome, samples) %>%
  unnest(samples)
sexage_sums <- fits %>%
  mutate(h = list(h_gwp, h_gwp, h_gwp, h_gbd, h_gbd, h_gbd)) %>%
  mutate(
    sums = map2(
      fit1, h,
      ~ simple_effects_summary(.x, .y)
    )
  ) %>%
  select(outcome, sums) %>%
  unnest(sums)

sexage_draws <- sexage_draws %>%
  mutate(f = if_else(str_detect(Hypothesis, "ale"), "Sex", "Age")) %>%
  mutate(is_average = region == "Average") %>%
  mutate(region = fct_relevel(region, "Average")) %>%
  mutate(
    side = if_else(Hypothesis %in% c("15 to 19", "Female"), "top", "bottom")
  )

sexage_sums <- sexage_sums %>%
  mutate(f = if_else(str_detect(Hypothesis, "ale"), "Sex", "Age")) %>%
  mutate(region = fct_relevel(region, "Average"))

# Plot averages and regions
sexage_draws %>%
  ggplot(aes(value, region, fill = Hypothesis, col = Hypothesis)) +
  scale_color_brewer(
    "Group",
    palette = "Dark2",
    aesthetics = c("fill", "color")
  ) +
  scale_alpha_manual(values = c(.4, .8), guide = "none") +
  geom_vline(xintercept = 0, lty = 2, size = .2) +
  scale_shape_manual(values = c(21, 19), guide = "none") +
  scale_y_discrete(
    expand = expansion(c(0.01, .1)),
    labels = function(x) {
      if_else(x == "Average", "**Average**", x) %>%
        str_replace("_", " ")
    }
  ) +
  scale_x_continuous(
    "Estimated linear change per decade",
    breaks = pretty_breaks(3),
    labels = function(x) {
      percent(x / 100, .01) %>%
        str_remove("\\.00") %>%
        str_remove("(?<=[0-9])0")
    },
    expand = expansion(c(-.05, -.05))
  ) +
  stat_halfeye(
    point_interval = mean_qi, normalize = "xy",
    height = 1, alpha = .5, point_fill = "white",
    .width = .95, interval_alpha = 1, interval_size = .2,
    point_alpha = 1, point_size = 1.5, stroke = .5,
    aes(
      shape = after_stat(xmin > 0 | xmax < 0)
    ),
    position = position_dodge(.8),
    key_glyph = draw_key_point
  ) +
  guides(
    color = guide_legend(
      override.aes = list(size = 2, alpha = 1),
      nrow = 2, ncol = 3, byrow = TRUE
    ),
    fill = guide_legend(
      nrow = 2, ncol = 3, byrow = TRUE
    )
  ) +
  # Add country points
  # geom_point(
  #   data = sexage_sums %>%
  #     drop_na(country) %>%
  #     mutate(is_average = TRUE),
  #   aes(
  #     x = Estimate,
  #     shape = CI.Lower > 0 | CI.Upper < 0,
  #     group = interaction(country, Hypothesis),
  #     ),
  #   position = position_dodgev(.7),
  #   size = .5, alpha = .3
  # ) +
  facet_wrap(
    "outcome",
    scales = "free_x", nrow = 1,
    labeller = as_labeller(~ str_replace(., "_", " "))
  ) +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_markdown(),
    legend.position = "bottom"
  )
```

### Associations

```{r model2-demographics}
#| column: screen-inset
#| fig-width: 14
#| fig-height: 9
#| fig-cap: "Forest plot of associations by demographic group"
#| label: fig-forest-association-demo
h_gwp <- c(
  `15 to 19` =
    "i1_cw + age1:i1_cw * 1 = 0",
  `20 to 24` =
    "i1_cw + age1:i1_cw * -1 = 0",
  `Female` =
    "i1_cw + sex1:i1_cw * 1 = 0",
  `Male` =
    "i1_cw + sex1:i1_cw * -1 = 0"
)
h_gbd <- c(
  `10 to 14` =
    "i1_cw + age1:i1_cw * 1 + age2:i1_cw * 0 = 0",
  `15 to 19` =
    "i1_cw + age1:i1_cw * 0 + age2:i1_cw * 1 = 0",
  `20 to 24` =
    "i1_cw + age1:i1_cw * -1 + age2:i1_cw * -1 = 0",
  `Female` =
    "i1_cw + sex1:i1_cw * 1 = 0",
  `Male` =
    "i1_cw + sex1:i1_cw * -1 = 0"
)

sexage_draws <- fits %>%
  mutate(h = list(h_gwp, h_gwp, h_gwp, h_gbd, h_gbd, h_gbd)) %>%
  mutate(
    samples = map2(
      fit2, h,
      ~ simple_effects_samples(.x, .y)
    )
  ) %>%
  select(outcome, samples) %>%
  unnest(samples)
sexage_sums <- fits %>%
  mutate(h = list(h_gwp, h_gwp, h_gwp, h_gbd, h_gbd, h_gbd)) %>%
  mutate(
    sums = map2(
      fit2, h,
      ~ simple_effects_summary(.x, .y)
    )
  ) %>%
  select(outcome, sums) %>%
  unnest(sums)

sexage_draws <- sexage_draws %>%
  mutate(f = if_else(str_detect(Hypothesis, "ale"), "Sex", "Age")) %>%
  mutate(is_average = region == "Average") %>%
  mutate(region = fct_relevel(region, "Average")) %>%
  mutate(
    side = if_else(Hypothesis %in% c("15 to 19", "Female"), "top", "bottom")
  )

sexage_sums <- sexage_sums %>%
  mutate(f = if_else(str_detect(Hypothesis, "ale"), "Sex", "Age")) %>%
  mutate(region = fct_relevel(region, "Average"))

# Plot averages and regions
sexage_draws %>%
  ggplot(aes(value, region, fill = Hypothesis, col = Hypothesis)) +
  scale_color_brewer(
    "Group",
    palette = "Dark2",
    aesthetics = c("fill", "color")
  ) +
  scale_alpha_manual(values = c(.4, .8), guide = "none") +
  geom_vline(xintercept = 0, lty = 2, size = .2) +
  scale_shape_manual(values = c(21, 19), guide = "none") +
  scale_y_discrete(
    expand = expansion(c(0.01, .1)),
    labels = function(x) {
      if_else(x == "Average", "**Average**", x) %>%
        str_replace("_", " ")
    }
  ) +
  scale_x_continuous(
    "Conditional effect of 100% increase in internet adoption on outcome",
    breaks = pretty_breaks(3),
    labels = function(x) {
      percent(x / 100, .01) %>%
        str_remove("\\.00") %>%
        str_remove("(?<=[0-9])0")
    },
    expand = expansion(c(-.05, -.05))
  ) +
  stat_halfeye(
    point_interval = mean_qi, normalize = "xy",
    height = 1, alpha = .5, point_fill = "white",
    .width = .95, interval_alpha = 1, interval_size = .2,
    point_alpha = 1, point_size = 1.5, stroke = .5,
    aes(
      shape = after_stat(xmin > 0 | xmax < 0)
    ),
    position = position_dodge(.8),
    key_glyph = draw_key_point
  ) +
  guides(
    color = guide_legend(
      override.aes = list(size = 2, alpha = 1),
      nrow = 2, ncol = 3, byrow = TRUE
    ),
    fill = guide_legend(
      nrow = 2, ncol = 3, byrow = TRUE
    )
  ) +
  # Add country points
  # geom_point(
  #   data = sexage_sums %>%
  #     drop_na(country) %>%
  #     mutate(is_average = TRUE),
  #   aes(
  #     x = Estimate,
  #     shape = CI.Lower > 0 | CI.Upper < 0,
  #     group = interaction(country, Hypothesis),
  #     ),
  #   position = position_dodgev(.7),
  #   size = .5, alpha = .3
  # ) +
  facet_wrap(
    "outcome",
    scales = "free_x", nrow = 1,
    labeller = as_labeller(~ str_replace(., "_", " "))
  ) +
  theme(
    axis.title.y = element_blank(),
    axis.text.y = element_markdown(),
    legend.position = "bottom"
  )
```

## Other internet metrics

Fixed and mobile broadband subscription analyses

```{r fixed-mobile-formulas}
bf_2_f <- bf(
  val | resp_se(se, sigma = TRUE) ~
  year * sex + year * age + f1_cw * sex + f1_cw * age + f1_cb +
    (year * sex + year * age + f1_cw * sex + f1_cw * age | country) +
    (year * sex + year * age + f1_cw * sex + f1_cw * age | region),
  family = gaussian(),
  unused = ~outcome
)

bf_2_m <- bf(
  val | resp_se(se, sigma = TRUE) ~
  year * sex + year * age + m1_cw * sex + m1_cw * age + m1_cb +
    (year * sex + year * age + m1_cw * sex + m1_cw * age | country) +
    (year * sex + year * age + m1_cw * sex + m1_cw * age | region),
  family = gaussian(),
  unused = ~outcome
)
```
